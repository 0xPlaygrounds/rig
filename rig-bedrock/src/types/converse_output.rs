//! Types that replace the AWS Bedrock Runtime SDK's `ConverseOutput` type.
//! This is required so that we can impl Serialize and Deserialize.
use std::{collections::HashMap, fmt};

use serde::{Deserialize, Serialize};

use super::errors::TypeConversionError;

/// Our own implementation of the AWS Bedrock runtime "converse" operation output.
/// The reason why we need to implement this is that we need to impl Deserialize/Serialize on top of this.
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct InternalConverseOutput {
    /// <p>The result from the call to <code>Converse</code>.</p>
    pub output: Option<ConverseOutput>,
    /// <p>The reason why the model stopped generating output.</p>
    pub stop_reason: StopReason,
    /// <p>The total number of tokens used in the call to <code>Converse</code>. The total includes the tokens input to the model and the tokens generated by the model.</p>
    pub usage: Option<TokenUsage>,
    /// <p>Metrics for the call to <code>Converse</code>.</p>
    pub metrics: Option<ConverseMetrics>,
    /// <p>Additional fields in the response that are unique to the model.</p>
    pub additional_model_response_fields: Option<Document>,
    /// <p>A trace object that contains information about the Guardrail behavior.</p>
    pub trace: Option<ConverseTrace>,
    /// <p>Model performance settings for the request.</p>
    pub performance_config: Option<PerformanceConfiguration>,
}

impl InternalConverseOutput {
    pub fn usage(&self) -> Option<&TokenUsage> {
        self.usage.as_ref()
    }
}

impl TryFrom<aws_sdk_bedrockruntime::operation::converse::ConverseOutput>
    for InternalConverseOutput
{
    type Error = TypeConversionError;

    fn try_from(
        value: aws_sdk_bedrockruntime::operation::converse::ConverseOutput,
    ) -> Result<Self, Self::Error> {
        let aws_sdk_bedrockruntime::operation::converse::ConverseOutput {
            output,
            stop_reason,
            usage,
            metrics,
            additional_model_response_fields,
            trace,
            performance_config,
            ..
        } = value;

        let res = Self {
            output: output.map(|x| x.try_into()).transpose()?,
            stop_reason: stop_reason.try_into()?,
            usage: usage.map(|x| x.try_into()).transpose()?,
            metrics: metrics.map(|x| x.try_into()).transpose()?,
            additional_model_response_fields: additional_model_response_fields
                .map(|x| x.try_into())
                .transpose()?,
            trace: trace.map(|x| x.try_into()).transpose()?,
            performance_config: performance_config.map(|x| x.try_into()).transpose()?,
        };

        Ok(res)
    }
}

#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum StopReason {
    ContentFiltered,
    EndTurn,
    GuardrailIntervened,
    MaxTokens,
    StopSequence,
    ToolUse,
    Unknown(UnknownVariantValue),
}

/// Opaque struct used as inner data for the `Unknown` variant defined in enums in
/// the crate.
///
/// This is not intended to be used directly.
#[derive(Clone, Eq, Ord, PartialEq, PartialOrd, Debug, Hash, Serialize, Deserialize)]
pub struct UnknownVariantValue(pub(crate) String);

impl fmt::Display for UnknownVariantValue {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct TokenUsage {
    pub input_tokens: i32,
    pub output_tokens: i32,
    pub total_tokens: i32,
    pub cache_read_input_tokens: Option<i32>,
    pub cache_write_input_tokens: Option<i32>,
}

#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct ConverseMetrics {
    pub latency_ms: i64,
}

#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct ConverseTrace {
    pub guardrail: Option<GuardrailTraceAssessment>,
    pub prompt_router: Option<PromptRouterTrace>,
}

#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct PromptRouterTrace {
    pub invoked_model_id: Option<String>,
}

#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct GuardrailTraceAssessment {
    pub model_output: Option<Vec<String>>,
    pub input_assessment: Option<HashMap<String, GuardrailAssessment>>,
    pub output_assessments: Option<HashMap<String, Vec<GuardrailAssessment>>>,
    pub action_reason: Option<String>,
}

#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct GuardrailAssessment {
    pub topic_policy: Option<GuardrailTopicPolicyAssessment>,
    pub content_policy: Option<GuardrailContentPolicyAssessment>,
    pub word_policy: Option<GuardrailWordPolicyAssessment>,
    pub sensitive_information_policy: Option<GuardrailSensitiveInformationPolicyAssessment>,
    pub contextual_grounding_policy: Option<GuardrailContextualGroundingPolicyAssessment>,
    pub invocation_metrics: Option<GuardrailInvocationMetrics>,
}

#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct GuardrailTopicPolicyAssessment {
    pub topics: Vec<GuardrailTopic>,
}

#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct GuardrailContentPolicyAssessment {
    pub filters: Vec<GuardrailContentFilter>,
}

#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct GuardrailWordPolicyAssessment {
    pub custom_words: Vec<GuardrailCustomWord>,
    pub managed_word_lists: Vec<GuardrailManagedWord>,
}

#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct GuardrailSensitiveInformationPolicyAssessment {
    pub pii_entities: Vec<GuardrailPiiEntityFilter>,
    pub regexes: Vec<GuardrailRegexFilter>,
}

#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct GuardrailContextualGroundingPolicyAssessment {
    pub filters: Option<Vec<GuardrailContextualGroundingFilter>>,
}

#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct GuardrailInvocationMetrics {
    pub guardrail_processing_latency: Option<i64>,
    pub usage: Option<GuardrailUsage>,
    pub guardrail_coverage: Option<GuardrailCoverage>,
}

#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct GuardrailTopic {
    pub name: String,
    #[serde(rename = "type")]
    pub kind: GuardrailTopicType,
    pub action: GuardrailTopicPolicyAction,
    pub detected: Option<bool>,
}

#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum GuardrailTopicType {
    Deny,
    Unknown(UnknownVariantValue),
}

#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum GuardrailTopicPolicyAction {
    Blocked,
    None,
    Unknown(UnknownVariantValue),
}

#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct GuardrailContentFilter {
    #[serde(rename = "type")]
    pub kind: GuardrailContentFilterType,
    pub confidence: GuardrailContentFilterConfidence,
    pub filter_strength: Option<GuardrailContentFilterStrength>,
    pub action: GuardrailContentPolicyAction,
    pub detected: Option<bool>,
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum GuardrailContentFilterConfidence {
    High,
    Low,
    Medium,
    None,
    Unknown(UnknownVariantValue),
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum GuardrailContentFilterStrength {
    High,
    Low,
    Medium,
    None,
    Unknown(UnknownVariantValue),
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum GuardrailContentPolicyAction {
    Blocked,
    None,
    Unknown(UnknownVariantValue),
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum GuardrailContentFilterType {
    Hate,
    Insults,
    Misconduct,
    PromptAttack,
    Sexual,
    Violence,
    Unknown(UnknownVariantValue),
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct GuardrailCustomWord {
    #[serde(rename = "match")]
    pub matches_on: String,
    pub action: GuardrailWordPolicyAction,
    pub detected: Option<bool>,
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum GuardrailWordPolicyAction {
    Blocked,
    None,
    Unknown(UnknownVariantValue),
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct GuardrailManagedWord {
    #[serde(rename = "match")]
    pub matches_on: String,
    #[serde(rename = "type")]
    pub kind: GuardrailManagedWordType,
    pub action: GuardrailWordPolicyAction,
    pub detected: Option<bool>,
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum GuardrailManagedWordType {
    Profanity,
    Unknown(UnknownVariantValue),
}

#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct GuardrailPiiEntityFilter {
    #[serde(rename = "match")]
    pub matches_on: String,
    #[serde(rename = "type")]
    pub kind: GuardrailPiiEntityType,
    pub action: GuardrailSensitiveInformationPolicyAction,
    pub detected: Option<bool>,
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum GuardrailSensitiveInformationPolicyAction {
    Anonymized,
    Blocked,
    None,
    Unknown(UnknownVariantValue),
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum GuardrailPiiEntityType {
    Address,
    Age,
    AwsAccessKey,
    AwsSecretKey,
    CaHealthNumber,
    CaSocialInsuranceNumber,
    CreditDebitCardCvv,
    CreditDebitCardExpiry,
    CreditDebitCardNumber,
    DriverId,
    Email,
    InternationalBankAccountNumber,
    IpAddress,
    LicensePlate,
    MacAddress,
    Name,
    Password,
    Phone,
    Pin,
    SwiftCode,
    UkNationalHealthServiceNumber,
    UkNationalInsuranceNumber,
    UkUniqueTaxpayerReferenceNumber,
    Url,
    Username,
    UsBankAccountNumber,
    UsBankRoutingNumber,
    UsIndividualTaxIdentificationNumber,
    UsPassportNumber,
    UsSocialSecurityNumber,
    VehicleIdentificationNumber,
    Unknown(UnknownVariantValue),
}

#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct GuardrailRegexFilter {
    pub name: Option<String>,
    #[serde(rename = "match")]
    pub matches_on: Option<String>,
    pub regex: Option<String>,
    pub action: GuardrailSensitiveInformationPolicyAction,
    pub detected: Option<bool>,
}

#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct GuardrailContextualGroundingFilter {
    #[serde(rename = "type")]
    pub kind: GuardrailContextualGroundingFilterType,
    pub threshold: f64,
    pub score: f64,
    pub action: GuardrailContextualGroundingPolicyAction,
    pub detected: Option<bool>,
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum GuardrailContextualGroundingFilterType {
    Grounding,
    Relevance,
    Unknown(UnknownVariantValue),
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum GuardrailContextualGroundingPolicyAction {
    Blocked,
    None,
    Unknown(UnknownVariantValue),
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct GuardrailUsage {
    pub topic_policy_units: i32,
    pub content_policy_units: i32,
    pub word_policy_units: i32,
    pub sensitive_information_policy_units: i32,
    pub sensitive_information_policy_free_units: i32,
    pub contextual_grounding_policy_units: i32,
    pub content_policy_image_units: Option<i32>,
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct GuardrailCoverage {
    pub text_characters: Option<GuardrailTextCharactersCoverage>,
    pub images: Option<GuardrailImageCoverage>,
}

#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct GuardrailTextCharactersCoverage {
    pub guarded: Option<i32>,
    pub total: Option<i32>,
}

#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct GuardrailImageCoverage {
    pub guarded: Option<i32>,
    pub total: Option<i32>,
}

#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct PerformanceConfiguration {
    pub latency: PerformanceConfigLatency,
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum PerformanceConfigLatency {
    Optimized,
    Standard,
    Unknown(UnknownVariantValue),
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum ConverseOutput {
    Message(Message),
    Unknown,
}

impl ConverseOutput {
    pub fn as_message(&self) -> Result<&Message, TypeConversionError> {
        match self {
            Self::Message(message) => Ok(message),
            invalid => Err(TypeConversionError::new(
                format!("Tried to get ConverseOutput as message but is invalid: {invalid:?}")
                    .as_ref(),
            )),
        }
    }
}

#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct Message {
    pub role: ConversationRole,
    pub content: Vec<ContentBlock>,
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum ConversationRole {
    Assistant,
    User,
    Unknown(UnknownVariantValue),
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum ContentBlock {
    CachePoint(CachePointBlock),
    CitationsContent(CitationsContentBlock),
    Document(DocumentBlock),
    GuardContent(GuardrailConverseContentBlock),
    Image(ImageBlock),
    ReasoningContent(ReasoningContentBlock),
    Text(String),
    ToolResult(ToolResultBlock),
    ToolUse(ToolUseBlock),
    Video(VideoBlock),
    #[non_exhaustive]
    Unknown,
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct CachePointBlock {
    #[serde(rename = "type")]
    pub kind: CachePointType,
}

#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum CachePointType {
    Default,
    Unknown(UnknownVariantValue),
}

#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct CitationsContentBlock {
    pub content: Option<Vec<CitationGeneratedContent>>,
    pub citations: Option<Vec<Citation>>,
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum CitationGeneratedContent {
    Text(String),
    Unknown,
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct Citation {
    pub title: Option<String>,
    pub source_content: Option<Vec<CitationSourceContent>>,
    pub location: Option<CitationLocation>,
}

#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum CitationSourceContent {
    Text(String),
    Unknown,
}

#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum CitationLocation {
    DocumentChar(DocumentCharLocation),
    DocumentChunk(DocumentChunkLocation),
    DocumentPage(DocumentPageLocation),
    #[non_exhaustive]
    Unknown,
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct DocumentCharLocation {
    pub document_index: Option<i32>,
    pub start: Option<i32>,
    pub end: Option<i32>,
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct DocumentChunkLocation {
    pub document_index: Option<i32>,
    pub start: Option<i32>,
    pub end: Option<i32>,
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct DocumentPageLocation {
    pub document_index: Option<i32>,
    pub start: Option<i32>,
    pub end: Option<i32>,
}

#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct DocumentBlock {
    pub format: DocumentFormat,
    pub name: String,
    pub source: Option<DocumentSource>,
    pub context: Option<String>,
    pub citations: Option<CitationsConfig>,
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum DocumentFormat {
    Csv,
    Doc,
    Docx,
    Html,
    Md,
    Pdf,
    Txt,
    Xls,
    Xlsx,
    Unknown(UnknownVariantValue),
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum DocumentSource {
    Bytes(Blob),
    Content(Vec<DocumentContentBlock>),
    S3Location(S3Location),
    Text(String),
    #[non_exhaustive]
    Unknown,
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum DocumentContentBlock {
    Text(String),
    Unknown,
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct S3Location {
    pub uri: String,
    pub bucket_owner: Option<String>,
}

#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct Blob {
    pub inner: Vec<u8>,
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct CitationsConfig {
    pub enabled: bool,
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum GuardrailConverseContentBlock {
    Image(GuardrailConverseImageBlock),
    Text(GuardrailConverseTextBlock),
    Unknown,
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct GuardrailConverseImageBlock {
    pub format: GuardrailConverseImageFormat,
    pub source: Option<GuardrailConverseImageSource>,
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum GuardrailConverseImageFormat {
    Jpeg,
    Png,
    Unknown(UnknownVariantValue),
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum GuardrailConverseImageSource {
    Bytes(Blob),
    #[non_exhaustive]
    Unknown,
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct GuardrailConverseTextBlock {
    pub text: String,
    pub qualifiers: Option<Vec<GuardrailConverseContentQualifier>>,
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum GuardrailConverseContentQualifier {
    GroundingSource,
    GuardContent,
    Query,
    Unknown(UnknownVariantValue),
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct ImageBlock {
    pub format: ImageFormat,
    pub source: Option<ImageSource>,
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum ImageFormat {
    Gif,
    Jpeg,
    Png,
    Webp,
    Unknown(UnknownVariantValue),
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum ImageSource {
    Bytes(Blob),
    S3Location(S3Location),
    #[non_exhaustive]
    Unknown,
}

#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum ReasoningContentBlock {
    ReasoningText(ReasoningTextBlock),
    RedactedContent(Blob),
    #[non_exhaustive]
    Unknown,
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct ReasoningTextBlock {
    pub text: String,
    pub signature: Option<String>,
}

#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct ToolResultBlock {
    pub tool_use_id: String,
    pub content: Vec<ToolResultContentBlock>,
    pub status: Option<ToolResultStatus>,
}

#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum ToolResultContentBlock {
    Document(DocumentBlock),
    Image(ImageBlock),
    Json(Document),
    Text(String),
    Video(VideoBlock),
    #[non_exhaustive]
    Unknown,
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct VideoBlock {
    pub format: VideoFormat,
    pub source: Option<VideoSource>,
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum VideoFormat {
    Flv,
    Mkv,
    Mov,
    Mp4,
    Mpeg,
    Mpg,
    ThreeGp,
    Webm,
    Wmv,
    Unknown(UnknownVariantValue),
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum VideoSource {
    Bytes(Blob),
    S3Location(S3Location),
    #[non_exhaustive]
    Unknown,
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub struct ToolUseBlock {
    pub tool_use_id: String,
    pub name: String,
    pub input: Document,
}

#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum ToolResultStatus {
    /// Renamed due to linting
    #[serde(rename = "Error")]
    IsError,
    Success,
    Unknown(UnknownVariantValue),
}

#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum Document {
    Object(HashMap<String, Document>),
    Array(Vec<Document>),
    Number(Number),
    String(String),
    Bool(bool),
    Null,
}
#[derive(Clone, PartialEq, Debug, Serialize, Deserialize)]
pub enum Number {
    PosInt(u64),
    NegInt(i64),
    Float(f64),
}

impl From<aws_smithy_types::Number> for Number {
    fn from(value: aws_smithy_types::Number) -> Self {
        match value {
            aws_smithy_types::Number::Float(float) => Self::Float(float),
            aws_smithy_types::Number::NegInt(int) => Self::NegInt(int),
            aws_smithy_types::Number::PosInt(int) => Self::PosInt(int),
        }
    }
}

impl From<&aws_smithy_types::Number> for Number {
    fn from(value: &aws_smithy_types::Number) -> Self {
        match value {
            aws_smithy_types::Number::Float(float) => Self::Float(float.to_owned()),
            aws_smithy_types::Number::NegInt(int) => Self::NegInt(int.to_owned()),
            aws_smithy_types::Number::PosInt(int) => Self::PosInt(int.to_owned()),
        }
    }
}

impl From<Number> for aws_smithy_types::Number {
    fn from(value: Number) -> Self {
        match value {
            Number::Float(float) => aws_smithy_types::Number::Float(float),
            Number::NegInt(int) => aws_smithy_types::Number::NegInt(int),
            Number::PosInt(int) => aws_smithy_types::Number::PosInt(int),
        }
    }
}

// TryFrom<T> implementations
impl TryFrom<aws_sdk_bedrockruntime::types::StopReason> for StopReason {
    type Error = TypeConversionError;
    fn try_from(value: aws_sdk_bedrockruntime::types::StopReason) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::StopReason::ContentFiltered => {
                Ok(StopReason::ContentFiltered)
            }
            aws_sdk_bedrockruntime::types::StopReason::EndTurn => Ok(StopReason::EndTurn),
            aws_sdk_bedrockruntime::types::StopReason::GuardrailIntervened => {
                Ok(StopReason::GuardrailIntervened)
            }
            aws_sdk_bedrockruntime::types::StopReason::MaxTokens => Ok(StopReason::MaxTokens),
            aws_sdk_bedrockruntime::types::StopReason::StopSequence => Ok(StopReason::StopSequence),
            aws_sdk_bedrockruntime::types::StopReason::ToolUse => Ok(StopReason::ToolUse),
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for StopReason: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::TokenUsage> for TokenUsage {
    type Error = TypeConversionError;
    fn try_from(value: aws_sdk_bedrockruntime::types::TokenUsage) -> Result<Self, Self::Error> {
        Ok(TokenUsage {
            input_tokens: value.input_tokens(),
            output_tokens: value.output_tokens(),
            total_tokens: value.total_tokens(),
            cache_read_input_tokens: value.cache_read_input_tokens(),
            cache_write_input_tokens: value.cache_write_input_tokens(),
        })
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::ConverseMetrics> for ConverseMetrics {
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::ConverseMetrics,
    ) -> Result<Self, Self::Error> {
        Ok(ConverseMetrics {
            latency_ms: value.latency_ms(),
        })
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::ConverseTrace> for ConverseTrace {
    type Error = TypeConversionError;
    fn try_from(value: aws_sdk_bedrockruntime::types::ConverseTrace) -> Result<Self, Self::Error> {
        Ok(ConverseTrace {
            guardrail: value.guardrail().map(|v| v.try_into()).transpose()?,
            prompt_router: value.prompt_router().map(|v| v.try_into()).transpose()?,
        })
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::PromptRouterTrace> for PromptRouterTrace {
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::PromptRouterTrace,
    ) -> Result<Self, Self::Error> {
        Ok(PromptRouterTrace {
            invoked_model_id: value.invoked_model_id().map(Into::into),
        })
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::PromptRouterTrace> for PromptRouterTrace {
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::PromptRouterTrace,
    ) -> Result<Self, Self::Error> {
        Ok(PromptRouterTrace {
            invoked_model_id: value.invoked_model_id().map(Into::into),
        })
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::GuardrailTraceAssessment> for GuardrailTraceAssessment {
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::GuardrailTraceAssessment,
    ) -> Result<Self, Self::Error> {
        let input_assessment = value
            .input_assessment()
            .map(|map| {
                map.iter()
                    .map(|(k, v)| Ok((k.clone(), v.clone().try_into()?)))
                    .collect::<Result<_, Self::Error>>()
            })
            .transpose()?;

        let output_assessments = value
            .output_assessments()
            .map(|map| {
                map.iter()
                    .map(|(k, v)| {
                        let converted_vec: Result<Vec<GuardrailAssessment>, Self::Error> =
                            v.iter().map(|x| x.clone().try_into()).collect();
                        Ok((k.clone(), converted_vec?))
                    })
                    .collect::<Result<_, Self::Error>>()
            })
            .transpose()?;

        Ok(GuardrailTraceAssessment {
            model_output: Some(value.model_output().iter().map(|x| x.to_owned()).collect()),
            input_assessment,
            output_assessments,
            action_reason: value.action_reason().map(Into::into),
        })
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::GuardrailTraceAssessment>
    for GuardrailTraceAssessment
{
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::GuardrailTraceAssessment,
    ) -> Result<Self, Self::Error> {
        let input_assessment = value
            .input_assessment()
            .map(|map| {
                map.iter()
                    .map(|(k, v)| Ok((k.clone(), v.clone().try_into()?)))
                    .collect::<Result<_, Self::Error>>()
            })
            .transpose()?;

        let output_assessments = value
            .output_assessments()
            .map(|map| {
                map.iter()
                    .map(|(k, v)| {
                        let converted_vec: Result<Vec<GuardrailAssessment>, Self::Error> =
                            v.iter().map(|x| x.clone().try_into()).collect();
                        Ok((k.clone(), converted_vec?))
                    })
                    .collect::<Result<_, Self::Error>>()
            })
            .transpose()?;

        Ok(GuardrailTraceAssessment {
            model_output: Some(value.model_output().iter().map(|x| x.to_owned()).collect()),
            input_assessment,
            output_assessments,
            action_reason: value.action_reason().map(Into::into),
        })
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::GuardrailAssessment> for GuardrailAssessment {
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::GuardrailAssessment,
    ) -> Result<Self, Self::Error> {
        Ok(GuardrailAssessment {
            topic_policy: value.topic_policy().map(|v| v.try_into()).transpose()?,
            content_policy: value.content_policy().map(|v| v.try_into()).transpose()?,
            word_policy: value.word_policy().map(|v| v.try_into()).transpose()?,
            sensitive_information_policy: value
                .sensitive_information_policy()
                .map(|v| v.try_into())
                .transpose()?,
            contextual_grounding_policy: value
                .contextual_grounding_policy()
                .map(|v| v.try_into())
                .transpose()?,
            invocation_metrics: value
                .invocation_metrics()
                .map(|v| v.try_into())
                .transpose()?,
        })
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::GuardrailTopicPolicyAssessment>
    for GuardrailTopicPolicyAssessment
{
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::GuardrailTopicPolicyAssessment,
    ) -> Result<Self, Self::Error> {
        Ok(GuardrailTopicPolicyAssessment {
            topics: value
                .topics()
                .iter()
                .map(|v| v.clone().try_into())
                .collect::<Result<_, Self::Error>>()?,
        })
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::GuardrailTopicPolicyAssessment>
    for GuardrailTopicPolicyAssessment
{
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::GuardrailTopicPolicyAssessment,
    ) -> Result<Self, Self::Error> {
        Ok(GuardrailTopicPolicyAssessment {
            topics: value
                .topics()
                .iter()
                .map(|v| v.clone().try_into())
                .collect::<Result<_, Self::Error>>()?,
        })
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::GuardrailContentPolicyAssessment>
    for GuardrailContentPolicyAssessment
{
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::GuardrailContentPolicyAssessment,
    ) -> Result<Self, Self::Error> {
        Ok(GuardrailContentPolicyAssessment {
            filters: value
                .filters()
                .iter()
                .map(|v| v.clone().try_into())
                .collect::<Result<_, Self::Error>>()?,
        })
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::GuardrailContentPolicyAssessment>
    for GuardrailContentPolicyAssessment
{
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::GuardrailContentPolicyAssessment,
    ) -> Result<Self, Self::Error> {
        Ok(GuardrailContentPolicyAssessment {
            filters: value
                .filters()
                .iter()
                .map(|v| v.clone().try_into())
                .collect::<Result<_, Self::Error>>()?,
        })
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::GuardrailWordPolicyAssessment>
    for GuardrailWordPolicyAssessment
{
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::GuardrailWordPolicyAssessment,
    ) -> Result<Self, Self::Error> {
        Ok(GuardrailWordPolicyAssessment {
            custom_words: value
                .custom_words()
                .iter()
                .map(|v| v.clone().try_into())
                .collect::<Result<_, Self::Error>>()?,
            managed_word_lists: value
                .managed_word_lists()
                .iter()
                .map(|v| v.clone().try_into())
                .collect::<Result<_, Self::Error>>()?,
        })
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::GuardrailWordPolicyAssessment>
    for GuardrailWordPolicyAssessment
{
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::GuardrailWordPolicyAssessment,
    ) -> Result<Self, Self::Error> {
        Ok(GuardrailWordPolicyAssessment {
            custom_words: value
                .custom_words()
                .iter()
                .map(|v| v.clone().try_into())
                .collect::<Result<_, Self::Error>>()?,
            managed_word_lists: value
                .managed_word_lists()
                .iter()
                .map(|v| v.clone().try_into())
                .collect::<Result<_, Self::Error>>()?,
        })
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::GuardrailSensitiveInformationPolicyAssessment>
    for GuardrailSensitiveInformationPolicyAssessment
{
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::GuardrailSensitiveInformationPolicyAssessment,
    ) -> Result<Self, Self::Error> {
        Ok(GuardrailSensitiveInformationPolicyAssessment {
            pii_entities: value
                .pii_entities()
                .iter()
                .map(|v| v.clone().try_into())
                .collect::<Result<_, Self::Error>>()?,
            regexes: value
                .regexes()
                .iter()
                .map(|v| v.clone().try_into())
                .collect::<Result<_, Self::Error>>()?,
        })
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::GuardrailSensitiveInformationPolicyAssessment>
    for GuardrailSensitiveInformationPolicyAssessment
{
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::GuardrailSensitiveInformationPolicyAssessment,
    ) -> Result<Self, Self::Error> {
        Ok(GuardrailSensitiveInformationPolicyAssessment {
            pii_entities: value
                .pii_entities()
                .iter()
                .map(|v| v.clone().try_into())
                .collect::<Result<_, Self::Error>>()?,
            regexes: value
                .regexes()
                .iter()
                .map(|v| v.clone().try_into())
                .collect::<Result<_, Self::Error>>()?,
        })
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::GuardrailContextualGroundingPolicyAssessment>
    for GuardrailContextualGroundingPolicyAssessment
{
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::GuardrailContextualGroundingPolicyAssessment,
    ) -> Result<Self, Self::Error> {
        Ok(GuardrailContextualGroundingPolicyAssessment {
            filters: value
                .filters
                .map(|x| x.into_iter().map(|x| x.try_into().unwrap()).collect()),
        })
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::GuardrailContextualGroundingPolicyAssessment>
    for GuardrailContextualGroundingPolicyAssessment
{
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::GuardrailContextualGroundingPolicyAssessment,
    ) -> Result<Self, Self::Error> {
        Ok(GuardrailContextualGroundingPolicyAssessment {
            filters: value
                .filters
                .clone()
                .map(|x| x.into_iter().map(|x| x.try_into().unwrap()).collect()),
        })
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::GuardrailInvocationMetrics>
    for GuardrailInvocationMetrics
{
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::GuardrailInvocationMetrics,
    ) -> Result<Self, Self::Error> {
        Ok(GuardrailInvocationMetrics {
            guardrail_processing_latency: value.guardrail_processing_latency(),
            usage: value.usage().map(|v| v.try_into()).transpose()?,
            guardrail_coverage: value
                .guardrail_coverage()
                .map(|v| v.try_into())
                .transpose()?,
        })
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::GuardrailInvocationMetrics>
    for GuardrailInvocationMetrics
{
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::GuardrailInvocationMetrics,
    ) -> Result<Self, Self::Error> {
        Ok(GuardrailInvocationMetrics {
            guardrail_processing_latency: value.guardrail_processing_latency(),
            usage: value.usage().map(|v| v.try_into()).transpose()?,
            guardrail_coverage: value
                .guardrail_coverage()
                .map(|v| v.try_into())
                .transpose()?,
        })
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::GuardrailTopic> for GuardrailTopic {
    type Error = TypeConversionError;
    fn try_from(value: aws_sdk_bedrockruntime::types::GuardrailTopic) -> Result<Self, Self::Error> {
        Ok(GuardrailTopic {
            name: value.name().into(),
            kind: value.r#type().try_into()?,
            action: value.action().try_into()?,
            detected: value.detected(),
        })
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::GuardrailTopic> for GuardrailTopic {
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::GuardrailTopic,
    ) -> Result<Self, Self::Error> {
        Ok(GuardrailTopic {
            name: value.name().into(),
            kind: value.r#type().try_into()?,
            action: value.action().try_into()?,
            detected: value.detected(),
        })
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::GuardrailTopicType> for GuardrailTopicType {
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::GuardrailTopicType,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::GuardrailTopicType::Deny => Ok(GuardrailTopicType::Deny),
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for GuardrailTopicType: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::GuardrailTopicType> for GuardrailTopicType {
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::GuardrailTopicType,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::GuardrailTopicType::Deny => Ok(GuardrailTopicType::Deny),
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for GuardrailTopicType: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::GuardrailTopicPolicyAction>
    for GuardrailTopicPolicyAction
{
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::GuardrailTopicPolicyAction,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::GuardrailTopicPolicyAction::Blocked => {
                Ok(GuardrailTopicPolicyAction::Blocked)
            }
            aws_sdk_bedrockruntime::types::GuardrailTopicPolicyAction::None => {
                Ok(GuardrailTopicPolicyAction::None)
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for GuardrailTopicPolicyAction: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::GuardrailTopicPolicyAction>
    for GuardrailTopicPolicyAction
{
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::GuardrailTopicPolicyAction,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::GuardrailTopicPolicyAction::Blocked => {
                Ok(GuardrailTopicPolicyAction::Blocked)
            }
            aws_sdk_bedrockruntime::types::GuardrailTopicPolicyAction::None => {
                Ok(GuardrailTopicPolicyAction::None)
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for GuardrailTopicPolicyAction: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::GuardrailContentFilter> for GuardrailContentFilter {
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::GuardrailContentFilter,
    ) -> Result<Self, Self::Error> {
        Ok(GuardrailContentFilter {
            kind: value.r#type().try_into()?,
            confidence: value.confidence().try_into()?,
            filter_strength: value.filter_strength().map(|v| v.try_into()).transpose()?,
            action: value.action().try_into()?,
            detected: value.detected(),
        })
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::GuardrailContentFilter> for GuardrailContentFilter {
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::GuardrailContentFilter,
    ) -> Result<Self, Self::Error> {
        Ok(GuardrailContentFilter {
            kind: value.r#type().try_into()?,
            confidence: value.confidence().try_into()?,
            filter_strength: value.filter_strength().map(|v| v.try_into()).transpose()?,
            action: value.action().try_into()?,
            detected: value.detected(),
        })
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::GuardrailContentFilterConfidence>
    for GuardrailContentFilterConfidence
{
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::GuardrailContentFilterConfidence,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::GuardrailContentFilterConfidence::High => {
                Ok(GuardrailContentFilterConfidence::High)
            }
            aws_sdk_bedrockruntime::types::GuardrailContentFilterConfidence::Low => {
                Ok(GuardrailContentFilterConfidence::Low)
            }
            aws_sdk_bedrockruntime::types::GuardrailContentFilterConfidence::Medium => {
                Ok(GuardrailContentFilterConfidence::Medium)
            }
            aws_sdk_bedrockruntime::types::GuardrailContentFilterConfidence::None => {
                Ok(GuardrailContentFilterConfidence::None)
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for GuardrailContentFilterConfidence: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::GuardrailContentFilterConfidence>
    for GuardrailContentFilterConfidence
{
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::GuardrailContentFilterConfidence,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::GuardrailContentFilterConfidence::High => {
                Ok(GuardrailContentFilterConfidence::High)
            }
            aws_sdk_bedrockruntime::types::GuardrailContentFilterConfidence::Low => {
                Ok(GuardrailContentFilterConfidence::Low)
            }
            aws_sdk_bedrockruntime::types::GuardrailContentFilterConfidence::Medium => {
                Ok(GuardrailContentFilterConfidence::Medium)
            }
            aws_sdk_bedrockruntime::types::GuardrailContentFilterConfidence::None => {
                Ok(GuardrailContentFilterConfidence::None)
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for GuardrailContentFilterConfidence: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::GuardrailContentFilterStrength>
    for GuardrailContentFilterStrength
{
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::GuardrailContentFilterStrength,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::GuardrailContentFilterStrength::High => {
                Ok(GuardrailContentFilterStrength::High)
            }
            aws_sdk_bedrockruntime::types::GuardrailContentFilterStrength::Low => {
                Ok(GuardrailContentFilterStrength::Low)
            }
            aws_sdk_bedrockruntime::types::GuardrailContentFilterStrength::Medium => {
                Ok(GuardrailContentFilterStrength::Medium)
            }
            aws_sdk_bedrockruntime::types::GuardrailContentFilterStrength::None => {
                Ok(GuardrailContentFilterStrength::None)
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for GuardrailContentFilterStrength: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::GuardrailContentFilterStrength>
    for GuardrailContentFilterStrength
{
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::GuardrailContentFilterStrength,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::GuardrailContentFilterStrength::High => {
                Ok(GuardrailContentFilterStrength::High)
            }
            aws_sdk_bedrockruntime::types::GuardrailContentFilterStrength::Low => {
                Ok(GuardrailContentFilterStrength::Low)
            }
            aws_sdk_bedrockruntime::types::GuardrailContentFilterStrength::Medium => {
                Ok(GuardrailContentFilterStrength::Medium)
            }
            aws_sdk_bedrockruntime::types::GuardrailContentFilterStrength::None => {
                Ok(GuardrailContentFilterStrength::None)
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for GuardrailContentFilterStrength: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::GuardrailContentPolicyAction>
    for GuardrailContentPolicyAction
{
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::GuardrailContentPolicyAction,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::GuardrailContentPolicyAction::Blocked => {
                Ok(GuardrailContentPolicyAction::Blocked)
            }
            aws_sdk_bedrockruntime::types::GuardrailContentPolicyAction::None => {
                Ok(GuardrailContentPolicyAction::None)
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for GuardrailContentPolicyAction: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::GuardrailContentPolicyAction>
    for GuardrailContentPolicyAction
{
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::GuardrailContentPolicyAction,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::GuardrailContentPolicyAction::Blocked => {
                Ok(GuardrailContentPolicyAction::Blocked)
            }
            aws_sdk_bedrockruntime::types::GuardrailContentPolicyAction::None => {
                Ok(GuardrailContentPolicyAction::None)
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for GuardrailContentPolicyAction: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::GuardrailContentFilterType>
    for GuardrailContentFilterType
{
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::GuardrailContentFilterType,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::GuardrailContentFilterType::Hate => {
                Ok(GuardrailContentFilterType::Hate)
            }
            aws_sdk_bedrockruntime::types::GuardrailContentFilterType::Insults => {
                Ok(GuardrailContentFilterType::Insults)
            }
            aws_sdk_bedrockruntime::types::GuardrailContentFilterType::Misconduct => {
                Ok(GuardrailContentFilterType::Misconduct)
            }
            aws_sdk_bedrockruntime::types::GuardrailContentFilterType::PromptAttack => {
                Ok(GuardrailContentFilterType::PromptAttack)
            }
            aws_sdk_bedrockruntime::types::GuardrailContentFilterType::Sexual => {
                Ok(GuardrailContentFilterType::Sexual)
            }
            aws_sdk_bedrockruntime::types::GuardrailContentFilterType::Violence => {
                Ok(GuardrailContentFilterType::Violence)
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for GuardrailContentFilterType: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::GuardrailCustomWord> for GuardrailCustomWord {
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::GuardrailCustomWord,
    ) -> Result<Self, Self::Error> {
        Ok(GuardrailCustomWord {
            matches_on: value.r#match().into(),
            action: value.action().try_into()?,
            detected: value.detected(),
        })
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::GuardrailWordPolicyAction>
    for GuardrailWordPolicyAction
{
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::GuardrailWordPolicyAction,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::GuardrailWordPolicyAction::Blocked => {
                Ok(GuardrailWordPolicyAction::Blocked)
            }
            aws_sdk_bedrockruntime::types::GuardrailWordPolicyAction::None => {
                Ok(GuardrailWordPolicyAction::None)
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for GuardrailWordPolicyAction: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::GuardrailWordPolicyAction>
    for GuardrailWordPolicyAction
{
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::GuardrailWordPolicyAction,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::GuardrailWordPolicyAction::Blocked => {
                Ok(GuardrailWordPolicyAction::Blocked)
            }
            aws_sdk_bedrockruntime::types::GuardrailWordPolicyAction::None => {
                Ok(GuardrailWordPolicyAction::None)
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for GuardrailWordPolicyAction: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::GuardrailManagedWord> for GuardrailManagedWord {
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::GuardrailManagedWord,
    ) -> Result<Self, Self::Error> {
        Ok(GuardrailManagedWord {
            matches_on: value.r#match().into(),
            kind: value.r#type().try_into()?,
            action: value.action().try_into()?,
            detected: value.detected(),
        })
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::GuardrailManagedWordType> for GuardrailManagedWordType {
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::GuardrailManagedWordType,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::GuardrailManagedWordType::Profanity => {
                Ok(GuardrailManagedWordType::Profanity)
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for GuardrailManagedWordType: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::GuardrailManagedWordType>
    for GuardrailManagedWordType
{
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::GuardrailManagedWordType,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::GuardrailManagedWordType::Profanity => {
                Ok(GuardrailManagedWordType::Profanity)
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for GuardrailManagedWordType: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::GuardrailPiiEntityFilter> for GuardrailPiiEntityFilter {
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::GuardrailPiiEntityFilter,
    ) -> Result<Self, Self::Error> {
        Ok(GuardrailPiiEntityFilter {
            matches_on: value.r#match().into(),
            kind: value.r#type().try_into()?,
            action: value.action().try_into()?,
            detected: value.detected(),
        })
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::GuardrailSensitiveInformationPolicyAction>
    for GuardrailSensitiveInformationPolicyAction
{
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::GuardrailSensitiveInformationPolicyAction,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::GuardrailSensitiveInformationPolicyAction::Anonymized => {
                Ok(GuardrailSensitiveInformationPolicyAction::Anonymized)
            }
            aws_sdk_bedrockruntime::types::GuardrailSensitiveInformationPolicyAction::Blocked => {
                Ok(GuardrailSensitiveInformationPolicyAction::Blocked)
            }
            aws_sdk_bedrockruntime::types::GuardrailSensitiveInformationPolicyAction::None => {
                Ok(GuardrailSensitiveInformationPolicyAction::None)
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for GuardrailSensitiveInformationPolicyAction: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::GuardrailSensitiveInformationPolicyAction>
    for GuardrailSensitiveInformationPolicyAction
{
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::GuardrailSensitiveInformationPolicyAction,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::GuardrailSensitiveInformationPolicyAction::Anonymized => {
                Ok(GuardrailSensitiveInformationPolicyAction::Anonymized)
            }
            aws_sdk_bedrockruntime::types::GuardrailSensitiveInformationPolicyAction::Blocked => {
                Ok(GuardrailSensitiveInformationPolicyAction::Blocked)
            }
            aws_sdk_bedrockruntime::types::GuardrailSensitiveInformationPolicyAction::None => {
                Ok(GuardrailSensitiveInformationPolicyAction::None)
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for GuardrailSensitiveInformationPolicyAction: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::GuardrailPiiEntityType> for GuardrailPiiEntityType {
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::GuardrailPiiEntityType,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::Address => Ok(GuardrailPiiEntityType::Address),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::Age => Ok(GuardrailPiiEntityType::Age),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::AwsAccessKey => Ok(GuardrailPiiEntityType::AwsAccessKey),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::AwsSecretKey => Ok(GuardrailPiiEntityType::AwsSecretKey),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::CaHealthNumber => Ok(GuardrailPiiEntityType::CaHealthNumber),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::CaSocialInsuranceNumber => Ok(GuardrailPiiEntityType::CaSocialInsuranceNumber),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::CreditDebitCardCvv => Ok(GuardrailPiiEntityType::CreditDebitCardCvv),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::CreditDebitCardExpiry => Ok(GuardrailPiiEntityType::CreditDebitCardExpiry),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::CreditDebitCardNumber => Ok(GuardrailPiiEntityType::CreditDebitCardNumber),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::DriverId => Ok(GuardrailPiiEntityType::DriverId),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::Email => Ok(GuardrailPiiEntityType::Email),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::InternationalBankAccountNumber => Ok(GuardrailPiiEntityType::InternationalBankAccountNumber),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::IpAddress => Ok(GuardrailPiiEntityType::IpAddress),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::LicensePlate => Ok(GuardrailPiiEntityType::LicensePlate),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::MacAddress => Ok(GuardrailPiiEntityType::MacAddress),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::Name => Ok(GuardrailPiiEntityType::Name),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::Password => Ok(GuardrailPiiEntityType::Password),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::Phone => Ok(GuardrailPiiEntityType::Phone),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::Pin => Ok(GuardrailPiiEntityType::Pin),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::SwiftCode => Ok(GuardrailPiiEntityType::SwiftCode),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::UkNationalHealthServiceNumber => Ok(GuardrailPiiEntityType::UkNationalHealthServiceNumber),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::UkNationalInsuranceNumber => Ok(GuardrailPiiEntityType::UkNationalInsuranceNumber),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::UkUniqueTaxpayerReferenceNumber => Ok(GuardrailPiiEntityType::UkUniqueTaxpayerReferenceNumber),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::Url => Ok(GuardrailPiiEntityType::Url),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::Username => Ok(GuardrailPiiEntityType::Username),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::UsBankAccountNumber => Ok(GuardrailPiiEntityType::UsBankAccountNumber),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::UsBankRoutingNumber => Ok(GuardrailPiiEntityType::UsBankRoutingNumber),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::UsIndividualTaxIdentificationNumber => Ok(GuardrailPiiEntityType::UsIndividualTaxIdentificationNumber),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::UsPassportNumber => Ok(GuardrailPiiEntityType::UsPassportNumber),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::UsSocialSecurityNumber => Ok(GuardrailPiiEntityType::UsSocialSecurityNumber),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::VehicleIdentificationNumber => Ok(GuardrailPiiEntityType::VehicleIdentificationNumber),
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for GuardrailPiiEntityType: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::GuardrailPiiEntityType> for GuardrailPiiEntityType {
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::GuardrailPiiEntityType,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::Address => Ok(GuardrailPiiEntityType::Address),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::Age => Ok(GuardrailPiiEntityType::Age),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::AwsAccessKey => Ok(GuardrailPiiEntityType::AwsAccessKey),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::AwsSecretKey => Ok(GuardrailPiiEntityType::AwsSecretKey),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::CaHealthNumber => Ok(GuardrailPiiEntityType::CaHealthNumber),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::CaSocialInsuranceNumber => Ok(GuardrailPiiEntityType::CaSocialInsuranceNumber),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::CreditDebitCardCvv => Ok(GuardrailPiiEntityType::CreditDebitCardCvv),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::CreditDebitCardExpiry => Ok(GuardrailPiiEntityType::CreditDebitCardExpiry),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::CreditDebitCardNumber => Ok(GuardrailPiiEntityType::CreditDebitCardNumber),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::DriverId => Ok(GuardrailPiiEntityType::DriverId),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::Email => Ok(GuardrailPiiEntityType::Email),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::InternationalBankAccountNumber => Ok(GuardrailPiiEntityType::InternationalBankAccountNumber),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::IpAddress => Ok(GuardrailPiiEntityType::IpAddress),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::LicensePlate => Ok(GuardrailPiiEntityType::LicensePlate),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::MacAddress => Ok(GuardrailPiiEntityType::MacAddress),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::Name => Ok(GuardrailPiiEntityType::Name),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::Password => Ok(GuardrailPiiEntityType::Password),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::Phone => Ok(GuardrailPiiEntityType::Phone),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::Pin => Ok(GuardrailPiiEntityType::Pin),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::SwiftCode => Ok(GuardrailPiiEntityType::SwiftCode),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::UkNationalHealthServiceNumber => Ok(GuardrailPiiEntityType::UkNationalHealthServiceNumber),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::UkNationalInsuranceNumber => Ok(GuardrailPiiEntityType::UkNationalInsuranceNumber),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::UkUniqueTaxpayerReferenceNumber => Ok(GuardrailPiiEntityType::UkUniqueTaxpayerReferenceNumber),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::Url => Ok(GuardrailPiiEntityType::Url),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::Username => Ok(GuardrailPiiEntityType::Username),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::UsBankAccountNumber => Ok(GuardrailPiiEntityType::UsBankAccountNumber),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::UsBankRoutingNumber => Ok(GuardrailPiiEntityType::UsBankRoutingNumber),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::UsIndividualTaxIdentificationNumber => Ok(GuardrailPiiEntityType::UsIndividualTaxIdentificationNumber),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::UsPassportNumber => Ok(GuardrailPiiEntityType::UsPassportNumber),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::UsSocialSecurityNumber => Ok(GuardrailPiiEntityType::UsSocialSecurityNumber),
            aws_sdk_bedrockruntime::types::GuardrailPiiEntityType::VehicleIdentificationNumber => Ok(GuardrailPiiEntityType::VehicleIdentificationNumber),
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for GuardrailPiiEntityType: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::GuardrailRegexFilter> for GuardrailRegexFilter {
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::GuardrailRegexFilter,
    ) -> Result<Self, Self::Error> {
        Ok(GuardrailRegexFilter {
            name: value.name().map(Into::into),
            matches_on: value.r#match().map(Into::into),
            regex: value.regex().map(Into::into),
            action: value.action().try_into()?,
            detected: value.detected(),
        })
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::GuardrailRegexFilter> for GuardrailRegexFilter {
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::GuardrailRegexFilter,
    ) -> Result<Self, Self::Error> {
        Ok(GuardrailRegexFilter {
            name: value.name().map(Into::into),
            matches_on: value.r#match().map(Into::into),
            regex: value.regex().map(Into::into),
            action: value.action().try_into()?,
            detected: value.detected(),
        })
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::GuardrailContextualGroundingFilter>
    for GuardrailContextualGroundingFilter
{
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::GuardrailContextualGroundingFilter,
    ) -> Result<Self, Self::Error> {
        Ok(GuardrailContextualGroundingFilter {
            kind: value.r#type().try_into()?,
            threshold: value.threshold(),
            score: value.score(),
            action: value.action().try_into()?,
            detected: value.detected(),
        })
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::GuardrailContextualGroundingFilter>
    for GuardrailContextualGroundingFilter
{
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::GuardrailContextualGroundingFilter,
    ) -> Result<Self, Self::Error> {
        Ok(GuardrailContextualGroundingFilter {
            kind: value.r#type().try_into()?,
            threshold: value.threshold(),
            score: value.score(),
            action: value.action().try_into()?,
            detected: value.detected(),
        })
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::GuardrailContextualGroundingFilterType>
    for GuardrailContextualGroundingFilterType
{
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::GuardrailContextualGroundingFilterType,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::GuardrailContextualGroundingFilterType::Grounding => {
                Ok(GuardrailContextualGroundingFilterType::Grounding)
            }
            aws_sdk_bedrockruntime::types::GuardrailContextualGroundingFilterType::Relevance => {
                Ok(GuardrailContextualGroundingFilterType::Relevance)
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for GuardrailContextualGroundingFilterType: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::GuardrailContextualGroundingFilterType>
    for GuardrailContextualGroundingFilterType
{
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::GuardrailContextualGroundingFilterType,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::GuardrailContextualGroundingFilterType::Grounding => {
                Ok(GuardrailContextualGroundingFilterType::Grounding)
            }
            aws_sdk_bedrockruntime::types::GuardrailContextualGroundingFilterType::Relevance => {
                Ok(GuardrailContextualGroundingFilterType::Relevance)
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for GuardrailContextualGroundingFilterType: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::GuardrailContextualGroundingPolicyAction>
    for GuardrailContextualGroundingPolicyAction
{
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::GuardrailContextualGroundingPolicyAction,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::GuardrailContextualGroundingPolicyAction::Blocked => {
                Ok(GuardrailContextualGroundingPolicyAction::Blocked)
            }
            aws_sdk_bedrockruntime::types::GuardrailContextualGroundingPolicyAction::None => {
                Ok(GuardrailContextualGroundingPolicyAction::None)
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for GuardrailContextualGroundingPolicyAction: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::GuardrailContextualGroundingPolicyAction>
    for GuardrailContextualGroundingPolicyAction
{
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::GuardrailContextualGroundingPolicyAction,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::GuardrailContextualGroundingPolicyAction::Blocked => {
                Ok(GuardrailContextualGroundingPolicyAction::Blocked)
            }
            aws_sdk_bedrockruntime::types::GuardrailContextualGroundingPolicyAction::None => {
                Ok(GuardrailContextualGroundingPolicyAction::None)
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for GuardrailContextualGroundingPolicyAction: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::GuardrailUsage> for GuardrailUsage {
    type Error = TypeConversionError;
    fn try_from(value: aws_sdk_bedrockruntime::types::GuardrailUsage) -> Result<Self, Self::Error> {
        Ok(GuardrailUsage {
            topic_policy_units: value.topic_policy_units(),
            content_policy_units: value.content_policy_units(),
            word_policy_units: value.word_policy_units(),
            sensitive_information_policy_units: value.sensitive_information_policy_units(),
            sensitive_information_policy_free_units: value
                .sensitive_information_policy_free_units(),
            contextual_grounding_policy_units: value.contextual_grounding_policy_units(),
            content_policy_image_units: value.content_policy_image_units(),
        })
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::GuardrailUsage> for GuardrailUsage {
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::GuardrailUsage,
    ) -> Result<Self, Self::Error> {
        Ok(GuardrailUsage {
            topic_policy_units: value.topic_policy_units(),
            content_policy_units: value.content_policy_units(),
            word_policy_units: value.word_policy_units(),
            sensitive_information_policy_units: value.sensitive_information_policy_units(),
            sensitive_information_policy_free_units: value
                .sensitive_information_policy_free_units(),
            contextual_grounding_policy_units: value.contextual_grounding_policy_units(),
            content_policy_image_units: value.content_policy_image_units(),
        })
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::GuardrailCoverage> for GuardrailCoverage {
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::GuardrailCoverage,
    ) -> Result<Self, Self::Error> {
        Ok(GuardrailCoverage {
            text_characters: value.text_characters().map(|x| x.try_into().unwrap()),
            images: value.images().map(|x| x.try_into().unwrap()),
        })
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::GuardrailCoverage> for GuardrailCoverage {
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::GuardrailCoverage,
    ) -> Result<Self, Self::Error> {
        Ok(GuardrailCoverage {
            text_characters: value.text_characters().map(|x| x.try_into().unwrap()),
            images: value.images().map(|x| x.try_into().unwrap()),
        })
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::GuardrailTextCharactersCoverage>
    for GuardrailTextCharactersCoverage
{
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::GuardrailTextCharactersCoverage,
    ) -> Result<Self, Self::Error> {
        Ok(GuardrailTextCharactersCoverage {
            guarded: value.guarded(),
            total: value.total(),
        })
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::GuardrailTextCharactersCoverage>
    for GuardrailTextCharactersCoverage
{
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::GuardrailTextCharactersCoverage,
    ) -> Result<Self, Self::Error> {
        Ok(GuardrailTextCharactersCoverage {
            guarded: value.guarded(),
            total: value.total(),
        })
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::GuardrailImageCoverage> for GuardrailImageCoverage {
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::GuardrailImageCoverage,
    ) -> Result<Self, Self::Error> {
        Ok(GuardrailImageCoverage {
            guarded: value.guarded(),
            total: value.total(),
        })
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::GuardrailImageCoverage> for GuardrailImageCoverage {
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::GuardrailImageCoverage,
    ) -> Result<Self, Self::Error> {
        Ok(GuardrailImageCoverage {
            guarded: value.guarded(),
            total: value.total(),
        })
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::PerformanceConfiguration> for PerformanceConfiguration {
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::PerformanceConfiguration,
    ) -> Result<Self, Self::Error> {
        Ok(PerformanceConfiguration {
            latency: value.latency().try_into()?,
        })
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::PerformanceConfigLatency> for PerformanceConfigLatency {
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::PerformanceConfigLatency,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::PerformanceConfigLatency::Optimized => {
                Ok(PerformanceConfigLatency::Optimized)
            }
            aws_sdk_bedrockruntime::types::PerformanceConfigLatency::Standard => {
                Ok(PerformanceConfigLatency::Standard)
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for PerformanceConfigLatency: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::PerformanceConfigLatency>
    for PerformanceConfigLatency
{
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::PerformanceConfigLatency,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::PerformanceConfigLatency::Optimized => {
                Ok(PerformanceConfigLatency::Optimized)
            }
            aws_sdk_bedrockruntime::types::PerformanceConfigLatency::Standard => {
                Ok(PerformanceConfigLatency::Standard)
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for PerformanceConfigLatency: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::ConverseOutput> for ConverseOutput {
    type Error = TypeConversionError;
    fn try_from(value: aws_sdk_bedrockruntime::types::ConverseOutput) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::ConverseOutput::Message(message) => {
                Ok(ConverseOutput::Message(message.try_into()?))
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for ConverseOutput: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::Message> for Message {
    type Error = TypeConversionError;
    fn try_from(value: aws_sdk_bedrockruntime::types::Message) -> Result<Self, Self::Error> {
        Ok(Message {
            role: value.role().try_into()?,
            content: value
                .content()
                .iter()
                .map(|v| v.clone().try_into())
                .collect::<Result<_, Self::Error>>()?,
        })
    }
}

impl TryFrom<Message> for aws_sdk_bedrockruntime::types::Message {
    type Error = TypeConversionError;
    fn try_from(value: Message) -> Result<Self, Self::Error> {
        let role = Some(value.role.try_into()?);
        let content = Some(
            value
                .content
                .iter()
                .map(|v| v.clone().try_into())
                .collect::<Result<_, Self::Error>>()?,
        );
        let res = aws_sdk_bedrockruntime::types::Message::builder()
            .set_role(role)
            .set_content(content)
            .build()
            .expect("AWS SDK message conversion should never fail!");

        Ok(res)
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::ConversationRole> for ConversationRole {
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::ConversationRole,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::ConversationRole::Assistant => {
                Ok(ConversationRole::Assistant)
            }
            aws_sdk_bedrockruntime::types::ConversationRole::User => Ok(ConversationRole::User),
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for ConversationRole: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::ConversationRole> for ConversationRole {
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::ConversationRole,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::ConversationRole::Assistant => {
                Ok(ConversationRole::Assistant)
            }
            aws_sdk_bedrockruntime::types::ConversationRole::User => Ok(ConversationRole::User),
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for ConversationRole: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<ConversationRole> for aws_sdk_bedrockruntime::types::ConversationRole {
    type Error = TypeConversionError;
    fn try_from(value: ConversationRole) -> Result<Self, Self::Error> {
        match value {
            ConversationRole::Assistant => {
                Ok(aws_sdk_bedrockruntime::types::ConversationRole::Assistant)
            }
            ConversationRole::User => Ok(aws_sdk_bedrockruntime::types::ConversationRole::User),
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for ConversationRole: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::ContentBlock> for ContentBlock {
    type Error = TypeConversionError;
    fn try_from(value: aws_sdk_bedrockruntime::types::ContentBlock) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::ContentBlock::CachePoint(value) => {
                Ok(ContentBlock::CachePoint(value.try_into()?))
            }
            aws_sdk_bedrockruntime::types::ContentBlock::CitationsContent(value) => {
                Ok(ContentBlock::CitationsContent(value.try_into()?))
            }
            aws_sdk_bedrockruntime::types::ContentBlock::Document(value) => {
                Ok(ContentBlock::Document(value.try_into()?))
            }
            aws_sdk_bedrockruntime::types::ContentBlock::GuardContent(value) => {
                Ok(ContentBlock::GuardContent(value.try_into()?))
            }
            aws_sdk_bedrockruntime::types::ContentBlock::Image(value) => {
                Ok(ContentBlock::Image(value.try_into()?))
            }
            aws_sdk_bedrockruntime::types::ContentBlock::ReasoningContent(value) => {
                Ok(ContentBlock::ReasoningContent(value.try_into()?))
            }
            aws_sdk_bedrockruntime::types::ContentBlock::Text(value) => {
                Ok(ContentBlock::Text(value))
            }
            aws_sdk_bedrockruntime::types::ContentBlock::ToolResult(value) => {
                Ok(ContentBlock::ToolResult(value.try_into()?))
            }
            aws_sdk_bedrockruntime::types::ContentBlock::ToolUse(value) => {
                Ok(ContentBlock::ToolUse(value.try_into()?))
            }
            aws_sdk_bedrockruntime::types::ContentBlock::Video(value) => {
                Ok(ContentBlock::Video(value.try_into()?))
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for ContentBlock: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<ContentBlock> for aws_sdk_bedrockruntime::types::ContentBlock {
    type Error = TypeConversionError;
    fn try_from(value: ContentBlock) -> Result<Self, Self::Error> {
        match value {
            ContentBlock::CachePoint(value) => Ok(
                aws_sdk_bedrockruntime::types::ContentBlock::CachePoint(value.try_into()?),
            ),
            ContentBlock::CitationsContent(value) => Ok(
                aws_sdk_bedrockruntime::types::ContentBlock::CitationsContent(value.try_into()?),
            ),
            ContentBlock::Document(value) => Ok(
                aws_sdk_bedrockruntime::types::ContentBlock::Document(value.try_into()?),
            ),
            ContentBlock::GuardContent(value) => Ok(
                aws_sdk_bedrockruntime::types::ContentBlock::GuardContent(value.try_into()?),
            ),
            ContentBlock::Image(value) => Ok(aws_sdk_bedrockruntime::types::ContentBlock::Image(
                value.try_into()?,
            )),
            ContentBlock::ReasoningContent(value) => Ok(
                aws_sdk_bedrockruntime::types::ContentBlock::ReasoningContent(value.try_into()?),
            ),
            ContentBlock::Text(value) => {
                Ok(aws_sdk_bedrockruntime::types::ContentBlock::Text(value))
            }
            ContentBlock::ToolResult(value) => Ok(
                aws_sdk_bedrockruntime::types::ContentBlock::ToolResult(value.try_into()?),
            ),
            ContentBlock::ToolUse(value) => Ok(
                aws_sdk_bedrockruntime::types::ContentBlock::ToolUse(value.try_into()?),
            ),
            ContentBlock::Video(value) => Ok(aws_sdk_bedrockruntime::types::ContentBlock::Video(
                value.try_into()?,
            )),
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for ContentBlock: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::CachePointBlock> for CachePointBlock {
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::CachePointBlock,
    ) -> Result<Self, Self::Error> {
        Ok(CachePointBlock {
            kind: value.r#type().try_into()?,
        })
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::CachePointBlock> for CachePointBlock {
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::CachePointBlock,
    ) -> Result<Self, Self::Error> {
        Ok(CachePointBlock {
            kind: value.r#type().try_into()?,
        })
    }
}

impl TryFrom<CachePointBlock> for aws_sdk_bedrockruntime::types::CachePointBlock {
    type Error = TypeConversionError;
    fn try_from(value: CachePointBlock) -> Result<Self, Self::Error> {
        let res = aws_sdk_bedrockruntime::types::CachePointBlock::builder()
            .set_type(Some(value.kind.try_into()?))
            .build()
            .map_err(|x| TypeConversionError::new(format!("Converting from CachePointBlock to AWS CachePointBlock should never fail but it seems to have done so: {x}").as_ref()))?;

        Ok(res)
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::CachePointType> for CachePointType {
    type Error = TypeConversionError;
    fn try_from(value: aws_sdk_bedrockruntime::types::CachePointType) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::CachePointType::Default => Ok(CachePointType::Default),
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for CachePointType: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<CachePointType> for aws_sdk_bedrockruntime::types::CachePointType {
    type Error = TypeConversionError;
    fn try_from(value: CachePointType) -> Result<Self, Self::Error> {
        match value {
            CachePointType::Default => Ok(aws_sdk_bedrockruntime::types::CachePointType::Default),
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for CachePointType: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::CachePointType> for CachePointType {
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::CachePointType,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::CachePointType::Default => Ok(CachePointType::Default),
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for CachePointType: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::CitationsContentBlock> for CitationsContentBlock {
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::CitationsContentBlock,
    ) -> Result<Self, Self::Error> {
        Ok(CitationsContentBlock {
            content: Some(
                value
                    .content()
                    .iter()
                    .map(|x| x.clone().try_into())
                    .collect::<Result<_, Self::Error>>()?,
            ),

            citations: Some(
                value
                    .citations()
                    .iter()
                    .map(|x| x.clone().try_into())
                    .collect::<Result<_, Self::Error>>()?,
            ),
        })
    }
}

impl TryFrom<CitationsContentBlock> for aws_sdk_bedrockruntime::types::CitationsContentBlock {
    type Error = TypeConversionError;
    fn try_from(value: CitationsContentBlock) -> Result<Self, Self::Error> {
        let citations = value
            .citations
            .map(|x| x.into_iter().map(|x| x.try_into()).collect())
            .transpose()?;
        let content = value
            .content
            .map(|x| x.into_iter().map(|x| x.try_into()).collect())
            .transpose()?;
        let citations = aws_sdk_bedrockruntime::types::CitationsContentBlock::builder()
            .set_citations(citations)
            .set_content(content)
            .build();
        Ok(citations)
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::CitationGeneratedContent> for CitationGeneratedContent {
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::CitationGeneratedContent,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::CitationGeneratedContent::Text(value) => {
                Ok(CitationGeneratedContent::Text(value))
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for CitationGeneratedContent: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<CitationGeneratedContent> for aws_sdk_bedrockruntime::types::CitationGeneratedContent {
    type Error = TypeConversionError;
    fn try_from(value: CitationGeneratedContent) -> Result<Self, Self::Error> {
        match value {
            CitationGeneratedContent::Text(value) => {
                Ok(aws_sdk_bedrockruntime::types::CitationGeneratedContent::Text(value))
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for CitationGeneratedContent: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::CitationGeneratedContent>
    for CitationGeneratedContent
{
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::CitationGeneratedContent,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::CitationGeneratedContent::Text(value) => {
                Ok(CitationGeneratedContent::Text(value.to_owned()))
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for CitationGeneratedContent: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::Citation> for Citation {
    type Error = TypeConversionError;
    fn try_from(value: aws_sdk_bedrockruntime::types::Citation) -> Result<Self, Self::Error> {
        Ok(Citation {
            title: value.title().map(Into::into),
            source_content: Some(
                value
                    .source_content()
                    .iter()
                    .map(|x| x.try_into())
                    .collect::<Result<_, Self::Error>>()?,
            ),
            location: value.location().map(|v| v.try_into()).transpose()?,
        })
    }
}

impl TryFrom<Citation> for aws_sdk_bedrockruntime::types::Citation {
    type Error = TypeConversionError;
    fn try_from(value: Citation) -> Result<Self, Self::Error> {
        let title = value.title;
        let location = value.location.map(|x| x.try_into()).transpose()?;
        let content = value
            .source_content
            .map(|x| {
                x.into_iter()
                    .map(|x| x.try_into())
                    .collect::<Result<_, Self::Error>>()
            })
            .transpose()?;

        let builder = aws_sdk_bedrockruntime::types::Citation::builder()
            .set_title(title)
            .set_location(location)
            .set_source_content(content)
            .build();
        Ok(builder)
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::CitationSourceContent> for CitationSourceContent {
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::CitationSourceContent,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::CitationSourceContent::Text(value) => {
                Ok(CitationSourceContent::Text(value))
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for CitationSourceContent: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::CitationSourceContent> for CitationSourceContent {
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::CitationSourceContent,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::CitationSourceContent::Text(value) => {
                Ok(CitationSourceContent::Text(value.to_owned()))
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for CitationSourceContent: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<CitationSourceContent> for aws_sdk_bedrockruntime::types::CitationSourceContent {
    type Error = TypeConversionError;
    fn try_from(value: CitationSourceContent) -> Result<Self, Self::Error> {
        match value {
            CitationSourceContent::Text(value) => Ok(
                aws_sdk_bedrockruntime::types::CitationSourceContent::Text(value),
            ),
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for CitationSourceContent: {invalid:?}"
            ))),
        }
    }
}
impl TryFrom<aws_sdk_bedrockruntime::types::CitationLocation> for CitationLocation {
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::CitationLocation,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::CitationLocation::DocumentChar(value) => {
                Ok(CitationLocation::DocumentChar(value.try_into()?))
            }
            aws_sdk_bedrockruntime::types::CitationLocation::DocumentChunk(value) => {
                Ok(CitationLocation::DocumentChunk(value.try_into()?))
            }
            aws_sdk_bedrockruntime::types::CitationLocation::DocumentPage(value) => {
                Ok(CitationLocation::DocumentPage(value.try_into()?))
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for CitationLocation: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::CitationLocation> for CitationLocation {
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::CitationLocation,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::CitationLocation::DocumentChar(value) => {
                Ok(CitationLocation::DocumentChar(value.try_into()?))
            }
            aws_sdk_bedrockruntime::types::CitationLocation::DocumentChunk(value) => {
                Ok(CitationLocation::DocumentChunk(value.try_into()?))
            }
            aws_sdk_bedrockruntime::types::CitationLocation::DocumentPage(value) => {
                Ok(CitationLocation::DocumentPage(value.try_into()?))
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for CitationLocation: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<CitationLocation> for aws_sdk_bedrockruntime::types::CitationLocation {
    type Error = TypeConversionError;
    fn try_from(value: CitationLocation) -> Result<Self, Self::Error> {
        match value {
            CitationLocation::DocumentChar(value) => Ok(
                aws_sdk_bedrockruntime::types::CitationLocation::DocumentChar(value.try_into()?),
            ),
            CitationLocation::DocumentChunk(value) => Ok(
                aws_sdk_bedrockruntime::types::CitationLocation::DocumentChunk(value.try_into()?),
            ),
            CitationLocation::DocumentPage(value) => Ok(
                aws_sdk_bedrockruntime::types::CitationLocation::DocumentPage(value.try_into()?),
            ),
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for CitationLocation: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::DocumentCharLocation> for DocumentCharLocation {
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::DocumentCharLocation,
    ) -> Result<Self, Self::Error> {
        Ok(DocumentCharLocation {
            document_index: value.document_index(),
            start: value.start(),
            end: value.end(),
        })
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::DocumentCharLocation> for DocumentCharLocation {
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::DocumentCharLocation,
    ) -> Result<Self, Self::Error> {
        Ok(DocumentCharLocation {
            document_index: value.document_index(),
            start: value.start(),
            end: value.end(),
        })
    }
}

impl TryFrom<DocumentCharLocation> for aws_sdk_bedrockruntime::types::DocumentCharLocation {
    type Error = TypeConversionError;
    fn try_from(value: DocumentCharLocation) -> Result<Self, Self::Error> {
        let res = aws_sdk_bedrockruntime::types::DocumentCharLocation::builder()
            .set_document_index(value.document_index)
            .set_start(value.start)
            .set_end(value.end)
            .build();

        Ok(res)
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::DocumentChunkLocation> for DocumentChunkLocation {
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::DocumentChunkLocation,
    ) -> Result<Self, Self::Error> {
        Ok(DocumentChunkLocation {
            document_index: value.document_index(),
            start: value.start(),
            end: value.end(),
        })
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::DocumentChunkLocation> for DocumentChunkLocation {
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::DocumentChunkLocation,
    ) -> Result<Self, Self::Error> {
        Ok(DocumentChunkLocation {
            document_index: value.document_index(),
            start: value.start(),
            end: value.end(),
        })
    }
}

impl TryFrom<DocumentChunkLocation> for aws_sdk_bedrockruntime::types::DocumentChunkLocation {
    type Error = TypeConversionError;
    fn try_from(value: DocumentChunkLocation) -> Result<Self, Self::Error> {
        let res = aws_sdk_bedrockruntime::types::DocumentChunkLocation::builder()
            .set_document_index(value.document_index)
            .set_start(value.start)
            .set_end(value.end)
            .build();
        Ok(res)
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::DocumentPageLocation> for DocumentPageLocation {
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::DocumentPageLocation,
    ) -> Result<Self, Self::Error> {
        Ok(DocumentPageLocation {
            document_index: value.document_index(),
            start: value.start(),
            end: value.end(),
        })
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::DocumentPageLocation> for DocumentPageLocation {
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::DocumentPageLocation,
    ) -> Result<Self, Self::Error> {
        Ok(DocumentPageLocation {
            document_index: value.document_index(),
            start: value.start(),
            end: value.end(),
        })
    }
}

impl TryFrom<DocumentPageLocation> for aws_sdk_bedrockruntime::types::DocumentPageLocation {
    type Error = TypeConversionError;
    fn try_from(value: DocumentPageLocation) -> Result<Self, Self::Error> {
        let res = aws_sdk_bedrockruntime::types::DocumentPageLocation::builder()
            .set_document_index(value.document_index)
            .set_start(value.start)
            .set_end(value.end)
            .build();

        Ok(res)
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::DocumentBlock> for DocumentBlock {
    type Error = TypeConversionError;
    fn try_from(value: aws_sdk_bedrockruntime::types::DocumentBlock) -> Result<Self, Self::Error> {
        Ok(DocumentBlock {
            format: value.format().try_into()?,
            name: value.name().into(),
            source: value.source().map(|v| v.try_into()).transpose()?,
            context: value.context().map(Into::into),
            citations: value.citations().map(|v| v.try_into()).transpose()?,
        })
    }
}

impl TryFrom<DocumentBlock> for aws_sdk_bedrockruntime::types::DocumentBlock {
    type Error = TypeConversionError;
    fn try_from(value: DocumentBlock) -> Result<Self, Self::Error> {
        let format = Some(aws_sdk_bedrockruntime::types::DocumentFormat::try_from(
            value.format,
        )?);
        let name = value.name.into();
        let source = value.source.map(|v| v.try_into()).transpose()?;
        let context = value.context;
        let citations = value.citations.map(|v| v.try_into()).transpose()?;

        let res = aws_sdk_bedrockruntime::types::DocumentBlock::builder()
            .set_format(format)
            .set_name(name)
            .set_source(source)
            .set_context(context)
            .set_citations(citations)
            .build()
            .expect("aws document block conversion should not fail");

        Ok(res)
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::DocumentFormat> for DocumentFormat {
    type Error = TypeConversionError;
    fn try_from(value: aws_sdk_bedrockruntime::types::DocumentFormat) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::DocumentFormat::Csv => Ok(DocumentFormat::Csv),
            aws_sdk_bedrockruntime::types::DocumentFormat::Doc => Ok(DocumentFormat::Doc),
            aws_sdk_bedrockruntime::types::DocumentFormat::Docx => Ok(DocumentFormat::Docx),
            aws_sdk_bedrockruntime::types::DocumentFormat::Html => Ok(DocumentFormat::Html),
            aws_sdk_bedrockruntime::types::DocumentFormat::Md => Ok(DocumentFormat::Md),
            aws_sdk_bedrockruntime::types::DocumentFormat::Pdf => Ok(DocumentFormat::Pdf),
            aws_sdk_bedrockruntime::types::DocumentFormat::Txt => Ok(DocumentFormat::Txt),
            aws_sdk_bedrockruntime::types::DocumentFormat::Xls => Ok(DocumentFormat::Xls),
            aws_sdk_bedrockruntime::types::DocumentFormat::Xlsx => Ok(DocumentFormat::Xlsx),
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for DocumentFormat: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::DocumentFormat> for DocumentFormat {
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::DocumentFormat,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::DocumentFormat::Csv => Ok(DocumentFormat::Csv),
            aws_sdk_bedrockruntime::types::DocumentFormat::Doc => Ok(DocumentFormat::Doc),
            aws_sdk_bedrockruntime::types::DocumentFormat::Docx => Ok(DocumentFormat::Docx),
            aws_sdk_bedrockruntime::types::DocumentFormat::Html => Ok(DocumentFormat::Html),
            aws_sdk_bedrockruntime::types::DocumentFormat::Md => Ok(DocumentFormat::Md),
            aws_sdk_bedrockruntime::types::DocumentFormat::Pdf => Ok(DocumentFormat::Pdf),
            aws_sdk_bedrockruntime::types::DocumentFormat::Txt => Ok(DocumentFormat::Txt),
            aws_sdk_bedrockruntime::types::DocumentFormat::Xls => Ok(DocumentFormat::Xls),
            aws_sdk_bedrockruntime::types::DocumentFormat::Xlsx => Ok(DocumentFormat::Xlsx),
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for DocumentFormat: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<DocumentFormat> for aws_sdk_bedrockruntime::types::DocumentFormat {
    type Error = TypeConversionError;
    fn try_from(value: DocumentFormat) -> Result<Self, Self::Error> {
        match value {
            DocumentFormat::Csv => Ok(aws_sdk_bedrockruntime::types::DocumentFormat::Csv),
            DocumentFormat::Doc => Ok(aws_sdk_bedrockruntime::types::DocumentFormat::Doc),
            DocumentFormat::Docx => Ok(aws_sdk_bedrockruntime::types::DocumentFormat::Docx),
            DocumentFormat::Html => Ok(aws_sdk_bedrockruntime::types::DocumentFormat::Html),
            DocumentFormat::Md => Ok(aws_sdk_bedrockruntime::types::DocumentFormat::Md),
            DocumentFormat::Pdf => Ok(aws_sdk_bedrockruntime::types::DocumentFormat::Pdf),
            DocumentFormat::Txt => Ok(aws_sdk_bedrockruntime::types::DocumentFormat::Txt),
            DocumentFormat::Xls => Ok(aws_sdk_bedrockruntime::types::DocumentFormat::Xls),
            DocumentFormat::Xlsx => Ok(aws_sdk_bedrockruntime::types::DocumentFormat::Xlsx),
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for DocumentFormat: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::DocumentSource> for DocumentSource {
    type Error = TypeConversionError;
    fn try_from(value: aws_sdk_bedrockruntime::types::DocumentSource) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::DocumentSource::Bytes(value) => {
                Ok(DocumentSource::Bytes(value.try_into()?))
            }
            aws_sdk_bedrockruntime::types::DocumentSource::Content(value) => {
                Ok(DocumentSource::Content(
                    value
                        .iter()
                        .map(|x| x.clone().try_into())
                        .collect::<Result<_, Self::Error>>()?,
                ))
            }
            aws_sdk_bedrockruntime::types::DocumentSource::S3Location(value) => {
                Ok(DocumentSource::S3Location(value.try_into()?))
            }
            aws_sdk_bedrockruntime::types::DocumentSource::Text(value) => {
                Ok(DocumentSource::Text(value))
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for DocumentSource: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::DocumentSource> for DocumentSource {
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::DocumentSource,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::DocumentSource::Bytes(value) => {
                Ok(DocumentSource::Bytes(value.try_into()?))
            }
            aws_sdk_bedrockruntime::types::DocumentSource::Content(value) => {
                Ok(DocumentSource::Content(
                    value
                        .iter()
                        .map(|x| x.clone().try_into())
                        .collect::<Result<_, Self::Error>>()?,
                ))
            }
            aws_sdk_bedrockruntime::types::DocumentSource::S3Location(value) => {
                Ok(DocumentSource::S3Location(value.try_into()?))
            }
            aws_sdk_bedrockruntime::types::DocumentSource::Text(value) => {
                Ok(DocumentSource::Text(value.to_string()))
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for DocumentSource: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<DocumentSource> for aws_sdk_bedrockruntime::types::DocumentSource {
    type Error = TypeConversionError;
    fn try_from(value: DocumentSource) -> Result<Self, Self::Error> {
        match value {
            DocumentSource::Bytes(value) => Ok(
                aws_sdk_bedrockruntime::types::DocumentSource::Bytes(value.try_into()?),
            ),
            DocumentSource::Content(value) => {
                Ok(aws_sdk_bedrockruntime::types::DocumentSource::Content(
                    value
                        .iter()
                        .map(|x| x.clone().try_into())
                        .collect::<Result<_, Self::Error>>()?,
                ))
            }
            DocumentSource::S3Location(value) => Ok(
                aws_sdk_bedrockruntime::types::DocumentSource::S3Location(value.try_into()?),
            ),
            DocumentSource::Text(value) => {
                Ok(aws_sdk_bedrockruntime::types::DocumentSource::Text(value))
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for DocumentSource: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::DocumentContentBlock> for DocumentContentBlock {
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::DocumentContentBlock,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::DocumentContentBlock::Text(value) => {
                Ok(DocumentContentBlock::Text(value))
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for DocumentContentBlock: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<DocumentContentBlock> for aws_sdk_bedrockruntime::types::DocumentContentBlock {
    type Error = TypeConversionError;
    fn try_from(value: DocumentContentBlock) -> Result<Self, Self::Error> {
        match value {
            DocumentContentBlock::Text(value) => Ok(
                aws_sdk_bedrockruntime::types::DocumentContentBlock::Text(value),
            ),
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for DocumentContentBlock: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::S3Location> for S3Location {
    type Error = TypeConversionError;
    fn try_from(value: aws_sdk_bedrockruntime::types::S3Location) -> Result<Self, Self::Error> {
        Ok(S3Location {
            uri: value.uri().into(),
            bucket_owner: value.bucket_owner().map(Into::into),
        })
    }
}

impl TryFrom<S3Location> for aws_sdk_bedrockruntime::types::S3Location {
    type Error = TypeConversionError;
    fn try_from(value: S3Location) -> Result<Self, Self::Error> {
        let res = aws_sdk_bedrockruntime::types::S3Location::builder()
            .set_uri(Some(value.uri))
            .set_bucket_owner(value.bucket_owner)
            .build()
            .expect("converting S3 bucket location should never fail");

        Ok(res)
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::S3Location> for S3Location {
    type Error = TypeConversionError;
    fn try_from(value: &aws_sdk_bedrockruntime::types::S3Location) -> Result<Self, Self::Error> {
        Ok(S3Location {
            uri: value.uri().into(),
            bucket_owner: value.bucket_owner().map(Into::into),
        })
    }
}

impl TryFrom<aws_sdk_bedrockruntime::primitives::Blob> for Blob {
    type Error = TypeConversionError;
    fn try_from(value: aws_sdk_bedrockruntime::primitives::Blob) -> Result<Self, Self::Error> {
        Ok(Blob {
            inner: value.clone().into_inner(),
        })
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::primitives::Blob> for Blob {
    type Error = TypeConversionError;
    fn try_from(value: &aws_sdk_bedrockruntime::primitives::Blob) -> Result<Self, Self::Error> {
        Ok(Blob {
            inner: value.clone().into_inner(),
        })
    }
}

impl TryFrom<Blob> for aws_sdk_bedrockruntime::primitives::Blob {
    type Error = TypeConversionError;
    fn try_from(value: Blob) -> Result<Self, Self::Error> {
        let res = aws_sdk_bedrockruntime::primitives::Blob::new(value.inner);
        Ok(res)
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::CitationsConfig> for CitationsConfig {
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::CitationsConfig,
    ) -> Result<Self, Self::Error> {
        Ok(CitationsConfig {
            enabled: value.enabled(),
        })
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::CitationsConfig> for CitationsConfig {
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::CitationsConfig,
    ) -> Result<Self, Self::Error> {
        Ok(CitationsConfig {
            enabled: value.enabled(),
        })
    }
}

impl TryFrom<CitationsConfig> for aws_sdk_bedrockruntime::types::CitationsConfig {
    type Error = TypeConversionError;
    fn try_from(value: CitationsConfig) -> Result<Self, Self::Error> {
        let res = aws_sdk_bedrockruntime::types::CitationsConfig::builder()
            .set_enabled(Some(value.enabled))
            .build()
            .expect("Citation config conversion should never fail!");

        Ok(res)
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::GuardrailConverseContentBlock>
    for GuardrailConverseContentBlock
{
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::GuardrailConverseContentBlock,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::GuardrailConverseContentBlock::Image(value) => {
                Ok(GuardrailConverseContentBlock::Image(value.try_into()?))
            }
            aws_sdk_bedrockruntime::types::GuardrailConverseContentBlock::Text(value) => {
                Ok(GuardrailConverseContentBlock::Text(value.try_into()?))
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for GuardrailConverseContentBlock: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<GuardrailConverseContentBlock>
    for aws_sdk_bedrockruntime::types::GuardrailConverseContentBlock
{
    type Error = TypeConversionError;
    fn try_from(value: GuardrailConverseContentBlock) -> Result<Self, Self::Error> {
        match value {
            GuardrailConverseContentBlock::Image(value) => Ok(
                aws_sdk_bedrockruntime::types::GuardrailConverseContentBlock::Image(
                    value.try_into()?,
                ),
            ),
            GuardrailConverseContentBlock::Text(value) => Ok(
                aws_sdk_bedrockruntime::types::GuardrailConverseContentBlock::Text(
                    value.try_into()?,
                ),
            ),
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for GuardrailConverseContentBlock: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::GuardrailConverseImageBlock>
    for GuardrailConverseImageBlock
{
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::GuardrailConverseImageBlock,
    ) -> Result<Self, Self::Error> {
        Ok(GuardrailConverseImageBlock {
            format: value.format().try_into()?,
            source: value.source().map(|v| v.try_into()).transpose()?,
        })
    }
}

impl TryFrom<GuardrailConverseImageBlock>
    for aws_sdk_bedrockruntime::types::GuardrailConverseImageBlock
{
    type Error = TypeConversionError;
    fn try_from(value: GuardrailConverseImageBlock) -> Result<Self, Self::Error> {
        let format = Some(value.format.try_into()?);
        let source = value.source.map(|v| v.try_into()).transpose()?;
        let res = aws_sdk_bedrockruntime::types::GuardrailConverseImageBlock::builder()
            .set_format(format)
            .set_source(source)
            .build()
            .expect("GuardrailConverseImageBlock conversion should never fail!");
        Ok(res)
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::GuardrailConverseImageFormat>
    for GuardrailConverseImageFormat
{
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::GuardrailConverseImageFormat,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::GuardrailConverseImageFormat::Jpeg => {
                Ok(GuardrailConverseImageFormat::Jpeg)
            }
            aws_sdk_bedrockruntime::types::GuardrailConverseImageFormat::Png => {
                Ok(GuardrailConverseImageFormat::Png)
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for GuardrailConverseImageFormat: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<GuardrailConverseImageFormat>
    for aws_sdk_bedrockruntime::types::GuardrailConverseImageFormat
{
    type Error = TypeConversionError;
    fn try_from(value: GuardrailConverseImageFormat) -> Result<Self, Self::Error> {
        match value {
            GuardrailConverseImageFormat::Jpeg => {
                Ok(aws_sdk_bedrockruntime::types::GuardrailConverseImageFormat::Jpeg)
            }
            GuardrailConverseImageFormat::Png => {
                Ok(aws_sdk_bedrockruntime::types::GuardrailConverseImageFormat::Png)
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for GuardrailConverseImageFormat: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::GuardrailConverseImageFormat>
    for GuardrailConverseImageFormat
{
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::GuardrailConverseImageFormat,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::GuardrailConverseImageFormat::Jpeg => {
                Ok(GuardrailConverseImageFormat::Jpeg)
            }
            aws_sdk_bedrockruntime::types::GuardrailConverseImageFormat::Png => {
                Ok(GuardrailConverseImageFormat::Png)
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for GuardrailConverseImageFormat: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::GuardrailConverseImageSource>
    for GuardrailConverseImageSource
{
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::GuardrailConverseImageSource,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::GuardrailConverseImageSource::Bytes(value) => {
                Ok(GuardrailConverseImageSource::Bytes(value.try_into()?))
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for GuardrailConverseImageSource: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::GuardrailConverseImageSource>
    for GuardrailConverseImageSource
{
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::GuardrailConverseImageSource,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::GuardrailConverseImageSource::Bytes(value) => {
                Ok(GuardrailConverseImageSource::Bytes(value.try_into()?))
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for GuardrailConverseImageSource: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<GuardrailConverseImageSource>
    for aws_sdk_bedrockruntime::types::GuardrailConverseImageSource
{
    type Error = TypeConversionError;
    fn try_from(value: GuardrailConverseImageSource) -> Result<Self, Self::Error> {
        match value {
            GuardrailConverseImageSource::Bytes(value) => Ok(
                aws_sdk_bedrockruntime::types::GuardrailConverseImageSource::Bytes(
                    value.try_into()?,
                ),
            ),
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for GuardrailConverseImageSource: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::GuardrailConverseTextBlock>
    for GuardrailConverseTextBlock
{
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::GuardrailConverseTextBlock,
    ) -> Result<Self, Self::Error> {
        Ok(GuardrailConverseTextBlock {
            text: value.text().into(),
            qualifiers: Some(
                value
                    .qualifiers()
                    .iter()
                    .map(|v| v.try_into())
                    .collect::<Result<_, Self::Error>>()?,
            ),
        })
    }
}

impl TryFrom<GuardrailConverseTextBlock>
    for aws_sdk_bedrockruntime::types::GuardrailConverseTextBlock
{
    type Error = TypeConversionError;
    fn try_from(value: GuardrailConverseTextBlock) -> Result<Self, Self::Error> {
        let text = Some(value.text);
        let qualifiers = value
            .qualifiers
            .map(|v| v.into_iter().map(|x| x.try_into()).collect())
            .transpose()?;
        let res = aws_sdk_bedrockruntime::types::GuardrailConverseTextBlock::builder()
            .set_text(text)
            .set_qualifiers(qualifiers)
            .build()
            .expect("GuardrailConversionTextBlock conversion should never fail!");

        Ok(res)
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::GuardrailConverseContentQualifier>
    for GuardrailConverseContentQualifier
{
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::GuardrailConverseContentQualifier,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::GuardrailConverseContentQualifier::GroundingSource => {
                Ok(GuardrailConverseContentQualifier::GroundingSource)
            }
            aws_sdk_bedrockruntime::types::GuardrailConverseContentQualifier::GuardContent => {
                Ok(GuardrailConverseContentQualifier::GuardContent)
            }
            aws_sdk_bedrockruntime::types::GuardrailConverseContentQualifier::Query => {
                Ok(GuardrailConverseContentQualifier::Query)
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for GuardrailConverseContentQualifier: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::GuardrailConverseContentQualifier>
    for GuardrailConverseContentQualifier
{
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::GuardrailConverseContentQualifier,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::GuardrailConverseContentQualifier::GroundingSource => {
                Ok(GuardrailConverseContentQualifier::GroundingSource)
            }
            aws_sdk_bedrockruntime::types::GuardrailConverseContentQualifier::GuardContent => {
                Ok(GuardrailConverseContentQualifier::GuardContent)
            }
            aws_sdk_bedrockruntime::types::GuardrailConverseContentQualifier::Query => {
                Ok(GuardrailConverseContentQualifier::Query)
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for GuardrailConverseContentQualifier: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<GuardrailConverseContentQualifier>
    for aws_sdk_bedrockruntime::types::GuardrailConverseContentQualifier
{
    type Error = TypeConversionError;
    fn try_from(value: GuardrailConverseContentQualifier) -> Result<Self, Self::Error> {
        match value {
            GuardrailConverseContentQualifier::GroundingSource => Ok(
                aws_sdk_bedrockruntime::types::GuardrailConverseContentQualifier::GroundingSource,
            ),
            GuardrailConverseContentQualifier::GuardContent => {
                Ok(aws_sdk_bedrockruntime::types::GuardrailConverseContentQualifier::GuardContent)
            }
            GuardrailConverseContentQualifier::Query => {
                Ok(aws_sdk_bedrockruntime::types::GuardrailConverseContentQualifier::Query)
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for GuardrailConverseContentQualifier: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::ImageBlock> for ImageBlock {
    type Error = TypeConversionError;
    fn try_from(value: aws_sdk_bedrockruntime::types::ImageBlock) -> Result<Self, Self::Error> {
        Ok(ImageBlock {
            format: value.format().try_into()?,
            source: value.source().map(|v| v.try_into()).transpose()?,
        })
    }
}

impl TryFrom<ImageBlock> for aws_sdk_bedrockruntime::types::ImageBlock {
    type Error = TypeConversionError;
    fn try_from(value: ImageBlock) -> Result<Self, Self::Error> {
        let format = Some(value.format.try_into()?);
        let source = value.source.map(|v| v.try_into()).transpose()?;
        let res = aws_sdk_bedrockruntime::types::ImageBlock::builder()
            .set_format(format)
            .set_source(source)
            .build()
            .expect("ImageBlock conversion should never fail!");
        Ok(res)
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::ImageFormat> for ImageFormat {
    type Error = TypeConversionError;
    fn try_from(value: aws_sdk_bedrockruntime::types::ImageFormat) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::ImageFormat::Gif => Ok(ImageFormat::Gif),
            aws_sdk_bedrockruntime::types::ImageFormat::Jpeg => Ok(ImageFormat::Jpeg),
            aws_sdk_bedrockruntime::types::ImageFormat::Png => Ok(ImageFormat::Png),
            aws_sdk_bedrockruntime::types::ImageFormat::Webp => Ok(ImageFormat::Webp),
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for ImageFormat: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::ImageFormat> for ImageFormat {
    type Error = TypeConversionError;
    fn try_from(value: &aws_sdk_bedrockruntime::types::ImageFormat) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::ImageFormat::Gif => Ok(ImageFormat::Gif),
            aws_sdk_bedrockruntime::types::ImageFormat::Jpeg => Ok(ImageFormat::Jpeg),
            aws_sdk_bedrockruntime::types::ImageFormat::Png => Ok(ImageFormat::Png),
            aws_sdk_bedrockruntime::types::ImageFormat::Webp => Ok(ImageFormat::Webp),
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for ImageFormat: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<ImageFormat> for aws_sdk_bedrockruntime::types::ImageFormat {
    type Error = TypeConversionError;
    fn try_from(value: ImageFormat) -> Result<Self, Self::Error> {
        match value {
            ImageFormat::Gif => Ok(aws_sdk_bedrockruntime::types::ImageFormat::Gif),
            ImageFormat::Jpeg => Ok(aws_sdk_bedrockruntime::types::ImageFormat::Jpeg),
            ImageFormat::Png => Ok(aws_sdk_bedrockruntime::types::ImageFormat::Png),
            ImageFormat::Webp => Ok(aws_sdk_bedrockruntime::types::ImageFormat::Webp),
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for ImageFormat: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::ImageSource> for ImageSource {
    type Error = TypeConversionError;
    fn try_from(value: aws_sdk_bedrockruntime::types::ImageSource) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::ImageSource::Bytes(value) => {
                Ok(ImageSource::Bytes(value.try_into()?))
            }
            aws_sdk_bedrockruntime::types::ImageSource::S3Location(value) => {
                Ok(ImageSource::S3Location(value.try_into()?))
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for ImageSource: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::ImageSource> for ImageSource {
    type Error = TypeConversionError;
    fn try_from(value: &aws_sdk_bedrockruntime::types::ImageSource) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::ImageSource::Bytes(value) => {
                Ok(ImageSource::Bytes(value.try_into()?))
            }
            aws_sdk_bedrockruntime::types::ImageSource::S3Location(value) => {
                Ok(ImageSource::S3Location(value.try_into()?))
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for ImageSource: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<ImageSource> for aws_sdk_bedrockruntime::types::ImageSource {
    type Error = TypeConversionError;
    fn try_from(value: ImageSource) -> Result<Self, Self::Error> {
        match value {
            ImageSource::Bytes(value) => Ok(aws_sdk_bedrockruntime::types::ImageSource::Bytes(
                value.try_into()?,
            )),
            ImageSource::S3Location(value) => Ok(
                aws_sdk_bedrockruntime::types::ImageSource::S3Location(value.try_into()?),
            ),
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for ImageSource: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::ReasoningContentBlock> for ReasoningContentBlock {
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::ReasoningContentBlock,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::ReasoningContentBlock::ReasoningText(value) => {
                Ok(ReasoningContentBlock::ReasoningText(value.try_into()?))
            }
            aws_sdk_bedrockruntime::types::ReasoningContentBlock::RedactedContent(value) => {
                Ok(ReasoningContentBlock::RedactedContent(value.try_into()?))
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for ReasoningContentBlock: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<ReasoningContentBlock> for aws_sdk_bedrockruntime::types::ReasoningContentBlock {
    type Error = TypeConversionError;
    fn try_from(value: ReasoningContentBlock) -> Result<Self, Self::Error> {
        match value {
            ReasoningContentBlock::ReasoningText(value) => Ok(
                aws_sdk_bedrockruntime::types::ReasoningContentBlock::ReasoningText(
                    value.try_into()?,
                ),
            ),
            ReasoningContentBlock::RedactedContent(value) => Ok(
                aws_sdk_bedrockruntime::types::ReasoningContentBlock::RedactedContent(
                    value.try_into()?,
                ),
            ),
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for ReasoningContentBlock: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::ReasoningTextBlock> for ReasoningTextBlock {
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::ReasoningTextBlock,
    ) -> Result<Self, Self::Error> {
        Ok(ReasoningTextBlock {
            text: value.text().into(),
            signature: value.signature().map(Into::into),
        })
    }
}

impl TryFrom<ReasoningTextBlock> for aws_sdk_bedrockruntime::types::ReasoningTextBlock {
    type Error = TypeConversionError;
    fn try_from(value: ReasoningTextBlock) -> Result<Self, Self::Error> {
        let text = value.text.into();
        let signature = value.signature;
        let res = aws_sdk_bedrockruntime::types::ReasoningTextBlock::builder()
            .set_text(text)
            .set_signature(signature)
            .build()
            .expect("ReasoningTextBlock conversion should never fail!");

        Ok(res)
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::ToolResultBlock> for ToolResultBlock {
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::ToolResultBlock,
    ) -> Result<Self, Self::Error> {
        Ok(ToolResultBlock {
            tool_use_id: value.tool_use_id().into(),
            content: value
                .content()
                .iter()
                .map(|v| v.clone().try_into())
                .collect::<Result<_, Self::Error>>()?,
            status: value.status().map(|v| v.try_into()).transpose()?,
        })
    }
}

impl TryFrom<ToolResultBlock> for aws_sdk_bedrockruntime::types::ToolResultBlock {
    type Error = TypeConversionError;
    fn try_from(value: ToolResultBlock) -> Result<Self, Self::Error> {
        let tool_use_id = Some(value.tool_use_id);
        let content = Some(
            value
                .content
                .into_iter()
                .map(|v| v.try_into())
                .collect::<Result<_, Self::Error>>()?,
        );
        let status = value.status.map(|v| v.try_into()).transpose()?;
        let res = aws_sdk_bedrockruntime::types::ToolResultBlock::builder()
            .set_tool_use_id(tool_use_id)
            .set_content(content)
            .set_status(status)
            .build()
            .expect("ToolResultBlock conversion should never fail!");
        Ok(res)
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::ToolResultContentBlock> for ToolResultContentBlock {
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::ToolResultContentBlock,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::ToolResultContentBlock::Document(value) => {
                Ok(ToolResultContentBlock::Document(value.try_into()?))
            }
            aws_sdk_bedrockruntime::types::ToolResultContentBlock::Image(value) => {
                Ok(ToolResultContentBlock::Image(value.try_into()?))
            }
            aws_sdk_bedrockruntime::types::ToolResultContentBlock::Json(value) => {
                Ok(ToolResultContentBlock::Json(value.try_into()?))
            }
            aws_sdk_bedrockruntime::types::ToolResultContentBlock::Text(value) => {
                Ok(ToolResultContentBlock::Text(value))
            }
            aws_sdk_bedrockruntime::types::ToolResultContentBlock::Video(value) => {
                Ok(ToolResultContentBlock::Video(value.try_into()?))
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for ToolResultContentBlock: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<ToolResultContentBlock> for aws_sdk_bedrockruntime::types::ToolResultContentBlock {
    type Error = TypeConversionError;
    fn try_from(value: ToolResultContentBlock) -> Result<Self, Self::Error> {
        match value {
            ToolResultContentBlock::Document(value) => Ok(
                aws_sdk_bedrockruntime::types::ToolResultContentBlock::Document(value.try_into()?),
            ),
            ToolResultContentBlock::Image(value) => {
                Ok(aws_sdk_bedrockruntime::types::ToolResultContentBlock::Image(value.try_into()?))
            }
            ToolResultContentBlock::Json(value) => Ok(
                aws_sdk_bedrockruntime::types::ToolResultContentBlock::Json(value.try_into()?),
            ),
            ToolResultContentBlock::Text(value) => Ok(
                aws_sdk_bedrockruntime::types::ToolResultContentBlock::Text(value),
            ),
            ToolResultContentBlock::Video(value) => {
                Ok(aws_sdk_bedrockruntime::types::ToolResultContentBlock::Video(value.try_into()?))
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for ToolResultContentBlock: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::VideoBlock> for VideoBlock {
    type Error = TypeConversionError;
    fn try_from(value: aws_sdk_bedrockruntime::types::VideoBlock) -> Result<Self, Self::Error> {
        Ok(VideoBlock {
            format: value.format().try_into()?,
            source: value.source().map(|v| v.try_into()).transpose()?,
        })
    }
}

impl TryFrom<VideoBlock> for aws_sdk_bedrockruntime::types::VideoBlock {
    type Error = TypeConversionError;
    fn try_from(value: VideoBlock) -> Result<Self, Self::Error> {
        let format = Some(value.format.try_into()?);
        let source = value.source.map(|v| v.try_into()).transpose()?;

        let res = aws_sdk_bedrockruntime::types::VideoBlock::builder()
            .set_format(format)
            .set_source(source)
            .build()
            .expect("VideoBlock conversion should never fail!");

        Ok(res)
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::VideoFormat> for VideoFormat {
    type Error = TypeConversionError;
    fn try_from(value: aws_sdk_bedrockruntime::types::VideoFormat) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::VideoFormat::Flv => Ok(VideoFormat::Flv),
            aws_sdk_bedrockruntime::types::VideoFormat::Mkv => Ok(VideoFormat::Mkv),
            aws_sdk_bedrockruntime::types::VideoFormat::Mov => Ok(VideoFormat::Mov),
            aws_sdk_bedrockruntime::types::VideoFormat::Mp4 => Ok(VideoFormat::Mp4),
            aws_sdk_bedrockruntime::types::VideoFormat::Mpeg => Ok(VideoFormat::Mpeg),
            aws_sdk_bedrockruntime::types::VideoFormat::Mpg => Ok(VideoFormat::Mpg),
            aws_sdk_bedrockruntime::types::VideoFormat::ThreeGp => Ok(VideoFormat::ThreeGp),
            aws_sdk_bedrockruntime::types::VideoFormat::Webm => Ok(VideoFormat::Webm),
            aws_sdk_bedrockruntime::types::VideoFormat::Wmv => Ok(VideoFormat::Wmv),
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for VideoFormat: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::VideoFormat> for VideoFormat {
    type Error = TypeConversionError;
    fn try_from(value: &aws_sdk_bedrockruntime::types::VideoFormat) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::VideoFormat::Flv => Ok(VideoFormat::Flv),
            aws_sdk_bedrockruntime::types::VideoFormat::Mkv => Ok(VideoFormat::Mkv),
            aws_sdk_bedrockruntime::types::VideoFormat::Mov => Ok(VideoFormat::Mov),
            aws_sdk_bedrockruntime::types::VideoFormat::Mp4 => Ok(VideoFormat::Mp4),
            aws_sdk_bedrockruntime::types::VideoFormat::Mpeg => Ok(VideoFormat::Mpeg),
            aws_sdk_bedrockruntime::types::VideoFormat::Mpg => Ok(VideoFormat::Mpg),
            aws_sdk_bedrockruntime::types::VideoFormat::ThreeGp => Ok(VideoFormat::ThreeGp),
            aws_sdk_bedrockruntime::types::VideoFormat::Webm => Ok(VideoFormat::Webm),
            aws_sdk_bedrockruntime::types::VideoFormat::Wmv => Ok(VideoFormat::Wmv),
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for VideoFormat: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<VideoFormat> for aws_sdk_bedrockruntime::types::VideoFormat {
    type Error = TypeConversionError;
    fn try_from(value: VideoFormat) -> Result<Self, Self::Error> {
        match value {
            VideoFormat::Flv => Ok(aws_sdk_bedrockruntime::types::VideoFormat::Flv),
            VideoFormat::Mkv => Ok(aws_sdk_bedrockruntime::types::VideoFormat::Mkv),
            VideoFormat::Mov => Ok(aws_sdk_bedrockruntime::types::VideoFormat::Mov),
            VideoFormat::Mp4 => Ok(aws_sdk_bedrockruntime::types::VideoFormat::Mp4),
            VideoFormat::Mpeg => Ok(aws_sdk_bedrockruntime::types::VideoFormat::Mpeg),
            VideoFormat::Mpg => Ok(aws_sdk_bedrockruntime::types::VideoFormat::Mpg),
            VideoFormat::ThreeGp => Ok(aws_sdk_bedrockruntime::types::VideoFormat::ThreeGp),
            VideoFormat::Webm => Ok(aws_sdk_bedrockruntime::types::VideoFormat::Webm),
            VideoFormat::Wmv => Ok(aws_sdk_bedrockruntime::types::VideoFormat::Wmv),
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for VideoFormat: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::VideoSource> for VideoSource {
    type Error = TypeConversionError;
    fn try_from(value: aws_sdk_bedrockruntime::types::VideoSource) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::VideoSource::Bytes(value) => {
                Ok(VideoSource::Bytes(value.try_into()?))
            }
            aws_sdk_bedrockruntime::types::VideoSource::S3Location(value) => {
                Ok(VideoSource::S3Location(value.try_into()?))
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for VideoSource: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::VideoSource> for VideoSource {
    type Error = TypeConversionError;
    fn try_from(value: &aws_sdk_bedrockruntime::types::VideoSource) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::VideoSource::Bytes(value) => {
                Ok(VideoSource::Bytes(value.try_into()?))
            }
            aws_sdk_bedrockruntime::types::VideoSource::S3Location(value) => {
                Ok(VideoSource::S3Location(value.try_into()?))
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for VideoSource: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<VideoSource> for aws_sdk_bedrockruntime::types::VideoSource {
    type Error = TypeConversionError;
    fn try_from(value: VideoSource) -> Result<Self, Self::Error> {
        match value {
            VideoSource::Bytes(value) => Ok(aws_sdk_bedrockruntime::types::VideoSource::Bytes(
                value.try_into()?,
            )),
            VideoSource::S3Location(value) => Ok(
                aws_sdk_bedrockruntime::types::VideoSource::S3Location(value.try_into()?),
            ),
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for VideoSource: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::ToolUseBlock> for ToolUseBlock {
    type Error = TypeConversionError;
    fn try_from(value: aws_sdk_bedrockruntime::types::ToolUseBlock) -> Result<Self, Self::Error> {
        Ok(ToolUseBlock {
            tool_use_id: value.tool_use_id().into(),
            name: value.name().into(),
            input: value.input().try_into()?,
        })
    }
}

impl TryFrom<ToolUseBlock> for aws_sdk_bedrockruntime::types::ToolUseBlock {
    type Error = TypeConversionError;
    fn try_from(value: ToolUseBlock) -> Result<Self, Self::Error> {
        let tool_use_id = value.tool_use_id.into();
        let name = value.name.into();
        let input = Some(value.input.try_into()?);

        let res = aws_sdk_bedrockruntime::types::ToolUseBlock::builder()
            .set_tool_use_id(tool_use_id)
            .set_name(name)
            .set_input(input)
            .build()
            .expect("ToolUseBlock shouldn't panic!");

        Ok(res)
    }
}

impl TryFrom<aws_sdk_bedrockruntime::types::ToolResultStatus> for ToolResultStatus {
    type Error = TypeConversionError;
    fn try_from(
        value: aws_sdk_bedrockruntime::types::ToolResultStatus,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::ToolResultStatus::Error => Ok(ToolResultStatus::IsError),
            aws_sdk_bedrockruntime::types::ToolResultStatus::Success => {
                Ok(ToolResultStatus::Success)
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for ToolResultStatus: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<&aws_sdk_bedrockruntime::types::ToolResultStatus> for ToolResultStatus {
    type Error = TypeConversionError;
    fn try_from(
        value: &aws_sdk_bedrockruntime::types::ToolResultStatus,
    ) -> Result<Self, Self::Error> {
        match value {
            aws_sdk_bedrockruntime::types::ToolResultStatus::Error => Ok(ToolResultStatus::IsError),
            aws_sdk_bedrockruntime::types::ToolResultStatus::Success => {
                Ok(ToolResultStatus::Success)
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for ToolResultStatus: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<ToolResultStatus> for aws_sdk_bedrockruntime::types::ToolResultStatus {
    type Error = TypeConversionError;
    fn try_from(
        value: ToolResultStatus,
    ) -> Result<
        Self,
        <aws_sdk_bedrockruntime::types::ToolResultStatus as TryFrom<ToolResultStatus>>::Error,
    > {
        match value {
            ToolResultStatus::IsError => Ok(aws_sdk_bedrockruntime::types::ToolResultStatus::Error),
            ToolResultStatus::Success => {
                Ok(aws_sdk_bedrockruntime::types::ToolResultStatus::Success)
            }
            invalid => Err(TypeConversionError::new(&format!(
                "Unknown variant for ToolResultStatus: {invalid:?}"
            ))),
        }
    }
}

impl TryFrom<aws_smithy_types::Document> for Document {
    type Error = TypeConversionError;
    fn try_from(value: aws_smithy_types::Document) -> Result<Self, Self::Error> {
        match value {
            aws_smithy_types::Document::Object(value) => Ok(Document::Object(
                value
                    .into_iter()
                    .map(|(k, v)| Ok((k, v.try_into()?)))
                    .collect::<Result<_, Self::Error>>()?,
            )),
            aws_smithy_types::Document::Array(value) => Ok(Document::Array(
                value
                    .into_iter()
                    .map(TryInto::try_into)
                    .collect::<Result<_, Self::Error>>()?,
            )),
            aws_smithy_types::Document::Number(value) => Ok(Document::Number(value.into())),
            aws_smithy_types::Document::String(value) => Ok(Document::String(value)),
            aws_smithy_types::Document::Bool(value) => Ok(Document::Bool(value)),
            aws_smithy_types::Document::Null => Ok(Document::Null),
        }
    }
}

impl TryFrom<&aws_smithy_types::Document> for Document {
    type Error = TypeConversionError;
    fn try_from(value: &aws_smithy_types::Document) -> Result<Self, Self::Error> {
        match value {
            aws_smithy_types::Document::Object(value) => Ok(Document::Object(
                value
                    .iter()
                    .map(|(k, v)| Ok((k.to_owned(), v.try_into()?)))
                    .collect::<Result<_, Self::Error>>()?,
            )),
            aws_smithy_types::Document::Array(value) => Ok(Document::Array(
                value
                    .iter()
                    .map(TryInto::try_into)
                    .collect::<Result<_, Self::Error>>()?,
            )),
            aws_smithy_types::Document::Number(value) => Ok(Document::Number(value.into())),
            aws_smithy_types::Document::String(value) => Ok(Document::String(value.to_owned())),
            aws_smithy_types::Document::Bool(value) => Ok(Document::Bool(value.to_owned())),
            aws_smithy_types::Document::Null => Ok(Document::Null),
        }
    }
}

impl TryFrom<Document> for aws_smithy_types::Document {
    type Error = TypeConversionError;
    fn try_from(value: Document) -> Result<Self, Self::Error> {
        match value {
            Document::Object(value) => Ok(aws_smithy_types::Document::Object(
                value
                    .into_iter()
                    .map(|(k, v)| Ok((k, v.try_into()?)))
                    .collect::<Result<_, Self::Error>>()?,
            )),
            Document::Array(value) => Ok(aws_smithy_types::Document::Array(
                value
                    .into_iter()
                    .map(TryInto::try_into)
                    .collect::<Result<_, Self::Error>>()?,
            )),
            Document::Number(value) => Ok(aws_smithy_types::Document::Number(value.into())),
            Document::String(value) => Ok(aws_smithy_types::Document::String(value)),
            Document::Bool(value) => Ok(aws_smithy_types::Document::Bool(value)),
            Document::Null => Ok(aws_smithy_types::Document::Null),
        }
    }
}

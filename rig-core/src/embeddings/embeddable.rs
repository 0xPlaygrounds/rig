//! The module defines the [Embeddable] trait, which must be implemented for types that can be embedded.
//! //! # Example
//! ```rust
//! use std::env;
//!
//! use serde::{Deserialize, Serialize};
//!
//! struct FakeDefinition {
//!     id: String,
//!     word: String,
//!     definitions: Vec<String>,
//! }
//!
//! let fake_definition = FakeDefinition {
//!     id: "doc1".to_string(),
//!     word: "hello".to_string(),
//!     definition: "used as a greeting or to begin a conversation".to_string()
//! };
//!
//! impl Embeddable for FakeDefinition {
//!     type Error = anyhow::Error;
//!
//!     fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
//!         // Embeddigns only need to be generated for `definition` field.
//!         // Select it from the struct and return it as a single item.
//!         Ok(OneOrMany::one(self.definition.clone()))
//!     }
//! }
//! ```

/// Error type used for when the `embeddable` method fails.
/// Used by default implementations of `Embeddable` for common types.
#[derive(Debug, thiserror::Error)]
pub enum EmbeddableError {
    #[error("SerdeError: {0}")]
    SerdeError(#[from] serde_json::Error),
}

/// Trait for types that can be embedded.
/// The `embeddable` method returns a OneOrMany<String> which contains strings for which embeddings will be generated by the embeddings builder.
/// If there is an error generating the list of strings, the method should return an error that implements `std::error::Error`.
pub trait Embeddable {
    type Error: std::error::Error;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error>;
}

/// Struct containing either a single item or a list of items of type T.
/// If a single item is present, `first` will contain it and `rest` will be empty.
/// If multiple items are present, `first` will contain the first item and `rest` will contain the rest.
/// IMPORTANT: this struct cannot be created with an empty vector.
/// OneOrMany objects can only be created using OneOrMany::one() or OneOrMany::many().
#[derive(PartialEq, Eq, Debug, Clone)]
pub struct OneOrMany<T> {
    /// First item in the list.
    first: T,
    /// Rest of the items in the list.
    rest: Vec<T>,
}

impl<T: Clone> OneOrMany<T> {
    /// Get the first item in the list.
    pub fn first(&self) -> T {
        self.first.clone()
    }

    /// Get the rest of the items in the list (excluding the first one).
    pub fn rest(&self) -> Vec<T> {
        self.rest.clone()
    }

    /// Create a OneOrMany object with a single item of any type.
    pub fn one(item: T) -> Self {
        OneOrMany {
            first: item,
            rest: vec![],
        }
    }

    /// Create a OneOrMany object with a vector of items of any type.
    pub fn many(items: Vec<T>) -> Self {
        let mut iter = items.into_iter();
        OneOrMany {
            first: match iter.next() {
                Some(item) => item,
                None => panic!("Cannot create OneOrMany with an empty vector."),
            },
            rest: iter.collect(),
        }
    }

    /// Use the Iterator trait on OneOrMany
    pub fn iter(&self) -> OneOrManyIterator<T> {
        OneOrManyIterator {
            one_or_many: self,
            index: 0,
        }
    }
}

/// Implement Iterator for OneOrMany.
/// Iterates over all items in both `first` and `rest`.
/// Borrows the OneOrMany object that is being iterator over.
pub struct OneOrManyIterator<'a, T> {
    one_or_many: &'a OneOrMany<T>,
    index: usize,
}

impl<'a, T> Iterator for OneOrManyIterator<'a, T> {
    type Item = &'a T;

    fn next(&mut self) -> Option<Self::Item> {
        let mut item = None;
        if self.index == 0 {
            item = Some(&self.one_or_many.first)
        } else if self.index - 1 < self.one_or_many.rest.len() {
            item = Some(&self.one_or_many.rest[self.index - 1]);
        };

        self.index += 1;
        item
    }
}

/// Implement IntoIterator for OneOrMany.
/// Iterates over all items in both `first` and `rest`.
/// Takes ownership the OneOrMany object that is being iterator over.
pub struct OneOrManyIntoIterator<T> {
    one_or_many: OneOrMany<T>,
    index: usize,
}

impl<T: Clone> IntoIterator for OneOrMany<T> {
    type Item = T;
    type IntoIter = OneOrManyIntoIterator<T>;

    fn into_iter(self) -> OneOrManyIntoIterator<T> {
        OneOrManyIntoIterator {
            one_or_many: self,
            index: 0,
        }
    }
}

impl<T: Clone> Iterator for OneOrManyIntoIterator<T> {
    type Item = T;

    fn next(&mut self) -> Option<Self::Item> {
        let mut item = None;
        if self.index == 0 {
            item = Some(self.one_or_many.first())
        } else if self.index - 1 < self.one_or_many.rest.len() {
            item = Some(self.one_or_many.rest[self.index - 1].clone());
        };

        self.index += 1;
        item
    }
}

/// Merge a list of OneOrMany items into a single OneOrMany item.
impl<T: Clone> From<Vec<OneOrMany<T>>> for OneOrMany<T> {
    fn from(value: Vec<OneOrMany<T>>) -> Self {
        let items = value
            .into_iter()
            .flat_map(|one_or_many| one_or_many.into_iter())
            .collect::<Vec<_>>();

        OneOrMany::many(items)
    }
}

//////////////////////////////////////////////////////
/// Implementations of Embeddable for common types ///
//////////////////////////////////////////////////////
impl Embeddable for String {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::one(self.clone()))
    }
}

impl Embeddable for i8 {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::one(self.to_string()))
    }
}

impl Embeddable for i16 {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::one(self.to_string()))
    }
}

impl Embeddable for i32 {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::one(self.to_string()))
    }
}

impl Embeddable for i64 {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::one(self.to_string()))
    }
}

impl Embeddable for i128 {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::one(self.to_string()))
    }
}

impl Embeddable for f32 {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::one(self.to_string()))
    }
}

impl Embeddable for f64 {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::one(self.to_string()))
    }
}

impl Embeddable for bool {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::one(self.to_string()))
    }
}

impl Embeddable for char {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::one(self.to_string()))
    }
}

impl Embeddable for serde_json::Value {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::one(
            serde_json::to_string(self).map_err(EmbeddableError::SerdeError)?,
        ))
    }
}

impl<T: Embeddable> Embeddable for Vec<T> {
    type Error = T::Error;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        let items = self
            .iter()
            .map(|item| item.embeddable())
            .collect::<Result<Vec<_>, _>>()?;

        Ok(OneOrMany::from(items))
    }
}

#[cfg(test)]
mod test {
    use super::OneOrMany;

    #[test]
    fn test_one_or_many_iter_single() {
        let one_or_many = OneOrMany::one("hello".to_string());

        assert_eq!(one_or_many.iter().count(), 1);

        one_or_many.iter().for_each(|i| {
            assert_eq!(i, "hello");
        });
    }

    #[test]
    fn test_one_or_many_iter() {
        let one_or_many = OneOrMany::many(vec!["hello".to_string(), "word".to_string()]);

        assert_eq!(one_or_many.iter().count(), 2);

        one_or_many.iter().enumerate().for_each(|(i, item)| {
            if i == 0 {
                assert_eq!(item, "hello");
            }
            if i == 1 {
                assert_eq!(item, "word");
            }
        });
    }

    #[test]
    fn test_one_or_many_into_iter_single() {
        let one_or_many = OneOrMany::one("hello".to_string());

        assert_eq!(one_or_many.clone().into_iter().count(), 1);

        one_or_many.into_iter().for_each(|i| {
            assert_eq!(i, "hello".to_string());
        });
    }

    #[test]
    fn test_one_or_many_into_iter() {
        let one_or_many = OneOrMany::many(vec!["hello".to_string(), "word".to_string()]);

        assert_eq!(one_or_many.clone().into_iter().count(), 2);

        one_or_many.into_iter().enumerate().for_each(|(i, item)| {
            if i == 0 {
                assert_eq!(item, "hello".to_string());
            }
            if i == 1 {
                assert_eq!(item, "word".to_string());
            }
        });
    }

    #[test]
    fn test_one_or_many_merge() {
        let one_or_many_1 = OneOrMany::many(vec!["hello".to_string(), "word".to_string()]);

        let one_or_many_2 = OneOrMany::one("sup".to_string());

        let merged = OneOrMany::from(vec![one_or_many_1, one_or_many_2]);

        assert_eq!(merged.iter().count(), 3);

        merged.iter().enumerate().for_each(|(i, item)| {
            if i == 0 {
                assert_eq!(item, "hello");
            }
            if i == 1 {
                assert_eq!(item, "word");
            }
            if i == 2 {
                assert_eq!(item, "sup");
            }
        });
    }
}

//! The module defines the [Embeddable] trait, which must be implemented for types that can be embedded.
//! //! # Example
//! ```rust
//! use std::env;
//!
//! use rig::Embeddable;
//! use serde::{Deserialize, Serialize};
//!
//! #[derive(Embeddable)]
//! struct FakeDefinition {
//!     id: String,
//!     word: String,
//!     #[embed]
//!     definitions: Vec<String>,
//! }
//!
//! // Do something with FakeDefinition
//! // ...
//! ```

/// The associated type `Kind` on the trait `Embeddable` must implement this trait.
pub trait EmbeddingKind {}

/// Used for structs that contain a single embedding target.
pub struct SingleEmbedding;
impl EmbeddingKind for SingleEmbedding {}

/// Used for structs that contain many embedding targets.
pub struct ManyEmbedding;
impl EmbeddingKind for ManyEmbedding {}

/// Error type used for when the `embeddable` method fails.
/// Used by default implementations of `Embeddable` for common types.
#[derive(Debug, thiserror::Error)]
pub enum EmbeddableError {
    #[error("SerdeError: {0}")]
    SerdeError(#[from] serde_json::Error),
    #[error("Error: {0}")]
    Error(String),
}

/// Trait for types that can be embedded.
/// The `embeddable` method returns a list of strings for which embeddings will be generated by the embeddings builder.
/// If the type `Kind` is `SingleEmbedding`, the list of strings contains a single item, otherwise, the list can contain many items.
/// If there is an error generating the list of strings, the method should return an error that implements `std::error::Error`.
pub trait Embeddable {
    type Error: std::error::Error;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error>;
}

#[derive(PartialEq, Eq, Debug)]
pub struct OneOrMany<T> {
    first: T,
    rest: Vec<T>,
}

impl<T: Clone> OneOrMany<T> {
    pub fn first(&self) -> T {
        self.first.clone()
    }

    pub fn rest(&self) -> Vec<T> {
        self.rest.clone()
    }

    pub fn all(&self) -> Vec<T> {
        let mut all = vec![self.first.clone()];
        all.extend(self.rest.clone());
        all
    }
}

impl<T> From<T> for OneOrMany<T> {
    fn from(item: T) -> Self {
        OneOrMany {
            first: item,
            rest: vec![],
        }
    }
}

impl<T> TryFrom<Vec<T>> for OneOrMany<T> {
    type Error = EmbeddableError;

    fn try_from(items: Vec<T>) -> Result<Self, Self::Error> {
        let mut iter = items.into_iter();
        Ok(OneOrMany {
            first: match iter.next() {
                Some(item) => item,
                None => {
                    return Err(EmbeddableError::Error(
                        "Cannot convert empty Vec to OneOrMany".to_string(),
                    ))
                }
            },
            rest: iter.collect(),
        })
    }
}

impl<T: Clone> TryFrom<Vec<OneOrMany<T>>> for OneOrMany<T> {
    type Error = EmbeddableError;

    fn try_from(value: Vec<OneOrMany<T>>) -> Result<Self, Self::Error> {
        let items = value
            .into_iter()
            .flat_map(|one_or_many| one_or_many.all())
            .collect::<Vec<_>>();

        OneOrMany::try_from(items)
    }
}

//////////////////////////////////////////////////////
/// Implementations of Embeddable for common types ///
//////////////////////////////////////////////////////
impl Embeddable for String {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::from(self.clone()))
    }
}

impl Embeddable for i8 {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::from(self.to_string()))
    }
}

impl Embeddable for i16 {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::from(self.to_string()))
    }
}

impl Embeddable for i32 {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::from(self.to_string()))
    }
}

impl Embeddable for i64 {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::from(self.to_string()))
    }
}

impl Embeddable for i128 {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::from(self.to_string()))
    }
}

impl Embeddable for f32 {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::from(self.to_string()))
    }
}

impl Embeddable for f64 {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::from(self.to_string()))
    }
}

impl Embeddable for bool {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::from(self.to_string()))
    }
}

impl Embeddable for char {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::from(self.to_string()))
    }
}

impl Embeddable for serde_json::Value {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::from(
            serde_json::to_string(self).map_err(EmbeddableError::SerdeError)?,
        ))
    }
}

impl<T: Embeddable> Embeddable for Vec<T> {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        let items = self
            .iter()
            .map(|item| item.embeddable())
            .collect::<Result<Vec<_>, _>>()
            .map_err(|e| EmbeddableError::Error(e.to_string()))?;

        OneOrMany::try_from(items)
    }
}

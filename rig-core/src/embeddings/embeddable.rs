//! The module defines the [Embeddable] trait, which must be implemented for types that can be embedded.
//! # Example
//! ```rust
//! use std::env;
//!
//! use serde::{Deserialize, Serialize};
//! use rig::OneOrMany;
//!
//! struct FakeDefinition {
//!     id: String,
//!     word: String,
//!     definition: String,
//! }
//!
//! let fake_definition = FakeDefinition {
//!     id: "doc1".to_string(),
//!     word: "hello".to_string(),
//!     definition: "used as a greeting or to begin a conversation".to_string()
//! };
//!
//! impl Embeddable for FakeDefinition {
//!     type Error = anyhow::Error;
//!
//!     fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
//!         // Embeddigns only need to be generated for `definition` field.
//!         // Select it from the struct and return it as a single item.
//!         Ok(OneOrMany::one(self.definition.clone()))
//!     }
//! }
//! ```

use crate::one_or_many::OneOrMany;

/// Error type used for when the `embeddable` method fails.
/// Used by default implementations of `Embeddable` for common types.
#[derive(Debug, thiserror::Error)]
#[error("{0}")]
pub struct EmbeddableError(#[from] Box<dyn std::error::Error + Send + Sync>);

impl EmbeddableError {
    pub fn new<E: std::error::Error + Send + Sync + 'static>(error: E) -> Self {
        EmbeddableError(Box::new(error))
    }
}

/// Trait for types that can be embedded.
/// The `embeddable` method returns a `OneOrMany<String>` which contains strings for which embeddings will be generated by the embeddings builder.
/// If there is an error generating the list of strings, the method should return an error that implements `std::error::Error`.
pub trait Embeddable {
    type Error: std::error::Error + Sync + Send + 'static;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error>;
}

// ================================================================
// Implementations of Embeddable for common types
// ================================================================
impl Embeddable for String {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::one(self.clone()))
    }
}

impl Embeddable for i8 {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::one(self.to_string()))
    }
}

impl Embeddable for i16 {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::one(self.to_string()))
    }
}

impl Embeddable for i32 {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::one(self.to_string()))
    }
}

impl Embeddable for i64 {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::one(self.to_string()))
    }
}

impl Embeddable for i128 {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::one(self.to_string()))
    }
}

impl Embeddable for f32 {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::one(self.to_string()))
    }
}

impl Embeddable for f64 {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::one(self.to_string()))
    }
}

impl Embeddable for bool {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::one(self.to_string()))
    }
}

impl Embeddable for char {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::one(self.to_string()))
    }
}

impl Embeddable for serde_json::Value {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::one(
            serde_json::to_string(self).map_err(EmbeddableError::new)?,
        ))
    }
}

impl<T: Embeddable> Embeddable for Vec<T> {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        let items = self
            .iter()
            .map(|item| item.embeddable())
            .collect::<Result<Vec<_>, _>>()
            .map_err(EmbeddableError::new)?;

        OneOrMany::merge(items).map_err(EmbeddableError::new)
    }
}

// #[derive(serde::Deserialize, serde::Serialize, Clone, Eq, PartialEq)]
// pub struct EmbeddableEmbeddable(serde_json::Value);

// impl EmbeddableEmbeddable {
//     pub fn new(item: impl serde::Serialize) -> serde_json::Result<Self> {
//         Ok(Self(serde_json::to_value(item)?))
//     }

//     pub fn cast<T: for<'a> Deserialize<'a>>(&self) -> serde_json::Result<T> {
//         serde_json::from_value(self.0.clone())
//     }
// }

// impl<I> crate::vector_store::VectorStoreIndexDyn for I
// where
//     I: crate::vector_store::VectorStoreIndex<EmbeddableEmbeddable>,
// {
//     fn top_n<'a>(
//         &'a self,
//         query: &'a str,
//         n: usize,
//     ) -> futures::future::BoxFuture<'a, crate::vector_store::TopNResults> {
//         Box::pin(async move {
//             Ok(self
//                 .top_n(query, n)
//                 .await?
//                 .into_iter()
//                 .map(|(distance, id, embeddable)| (distance, id, embeddable.0))
//                 .collect())
//         })
//     }

//     fn top_n_ids<'a>(
//         &'a self,
//         query: &'a str,
//         n: usize,
//     ) -> futures::future::BoxFuture<
//         'a,
//         Result<Vec<(f64, String)>, crate::vector_store::VectorStoreError>,
//     > {
//         Box::pin(self.top_n_ids(query, n))
//     }
// }

//! The module defines the [Embeddable] trait, which must be implemented for types that can be embedded.
//! # Example
//! ```rust
//! use std::env;
//!
//! use serde::{Deserialize, Serialize};
//! use rig::OneOrMany;
//!
//! struct FakeDefinition {
//!     id: String,
//!     word: String,
//!     definition: String,
//! }
//!
//! let fake_definition = FakeDefinition {
//!     id: "doc1".to_string(),
//!     word: "hello".to_string(),
//!     definition: "used as a greeting or to begin a conversation".to_string()
//! };
//!
//! impl Embeddable for FakeDefinition {
//!     type Error = anyhow::Error;
//!
//!     fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
//!         // Embeddigns only need to be generated for `definition` field.
//!         // Select it from the struct and return it as a single item.
//!         Ok(OneOrMany::one(self.definition.clone()))
//!     }
//! }
//! ```

use crate::one_or_many::OneOrMany;

/// Error type used for when the `embeddable` method fails.
/// Used by default implementations of `Embeddable` for common types.
#[derive(Debug, thiserror::Error)]
#[error("{0}")]
pub struct EmbeddableError(#[from] Box<dyn std::error::Error + Send + Sync>);

impl EmbeddableError {
    pub fn new<E: std::error::Error + Send + Sync + 'static>(error: E) -> Self {
        EmbeddableError(Box::new(error))
    }
}

/// Trait for types that can be embedded.
/// The `embeddable` method returns a `OneOrMany<String>` which contains strings for which embeddings will be generated by the embeddings builder.
/// If there is an error generating the list of strings, the method should return an error that implements `std::error::Error`.
pub trait Embeddable {
    type Error: std::error::Error + Sync + Send + 'static;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error>;
}

// ================================================================
// Implementations of Embeddable for common types
// ================================================================
impl Embeddable for String {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::one(self.clone()))
    }
}

impl Embeddable for i8 {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::one(self.to_string()))
    }
}

impl Embeddable for i16 {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::one(self.to_string()))
    }
}

impl Embeddable for i32 {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::one(self.to_string()))
    }
}

impl Embeddable for i64 {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::one(self.to_string()))
    }
}

impl Embeddable for i128 {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::one(self.to_string()))
    }
}

impl Embeddable for f32 {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::one(self.to_string()))
    }
}

impl Embeddable for f64 {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::one(self.to_string()))
    }
}

impl Embeddable for bool {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::one(self.to_string()))
    }
}

impl Embeddable for char {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::one(self.to_string()))
    }
}

impl Embeddable for serde_json::Value {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        Ok(OneOrMany::one(
            serde_json::to_string(self).map_err(EmbeddableError::new)?,
        ))
    }
}

impl<T: Embeddable> Embeddable for Vec<T> {
    type Error = EmbeddableError;

    fn embeddable(&self) -> Result<OneOrMany<String>, Self::Error> {
        let items = self
            .iter()
            .map(|item| item.embeddable())
            .collect::<Result<Vec<_>, _>>()
            .map_err(EmbeddableError::new)?;

        OneOrMany::merge(items).map_err(EmbeddableError::new)
    }
}
